$表示的是在文件中的真实地址

$$表示的是在段在文件中的真实地址

vstart给一个虚拟地址



**直接，间接，绝对，相对，远，近这6组概念区分**

实模式下的call

直接：目标函数的地址（操作数）直接给出，是个立即数。

间接：目标函数的地址没有直接给出，地址要么在寄存器中要么在内存中。

绝对：目标函数的地址是绝对地址，是段内偏移值。

相对：目标函数的地址是相对地址，相对当前指令的偏移值。（我理解的还有一层是相对于当前指令下一条指令的偏移值）

远：段间，目标函数和当前代码段不是一个段。

近：段内，目标函数和当前代码段是一个代码段。

前两种是近调用，后两种是远调用

- 16位实模式相对近调用
- 16位实模式间接绝对近调用
- 16位实模式直接绝对远调用
- 16位实模式间接绝对远调用

实模式下的jmp

- 16位实模式相对短转移
- 16位实模式相对近转移
- 16位实模式间接绝对近转移
- 16位实模式直接绝对远转移





约定个步骤：
（1）先选择通道，往该通道的 sector count 寄存器中写入待操作的扇区数。
（2）往该通道上的三个 LBA 寄存器写入扇区起始地址的低 24 位。
（3）往 device 寄存器中写入 LBA 地址的 24～27 位，并置第 6 位为 1，使其为 LBA 模式，设置第 4 位，选择操作的硬盘（master 硬盘或 slave 硬盘）。
（4）往该通道上的 command 寄存器写入操作命令。
（5）读取该通道上的 status 寄存器，判断硬盘工作是否完成。
（6）如果以上步骤是读硬盘，进入下一个步骤。否则，完工。
（7）将硬盘数据读出。



保护模式：

1.寻址扩展

2.运行模式扩展

3.指令扩展

![段描述符格式](/home/xiaoyao/图片/截图/段描述符格式.png)

段描述符是8B大小。

1.保护模式下地址总线宽度是 32 位，**段基址需要用 32 位地址来表示。**

2.段界限表示段边界的**扩展最值**，即最大扩展到多少或最小扩展到多少。扩展方向只有上下两种。如果 **G 位为 0**，表示段界限粒度大小为 1 字节；如果 **G 位为 1**，表示段界限粒度大小为 4KB字节。

3.CPU眼中，凡是**硬件运行**需要用到的东西都称之为系统段，凡是**软件需要**的东西都称之为数据段。无论是代码还是数据，他们都是软件运行的必须品，只不过借助硬件在硬件上运行，并不属于硬件运行的必须品，所以他们都称为数据。S为1表示数据段，S为0表示系统段。

4.type 字段，该字段共 4 位，用于表示内存段或门的子类型。**type 字段是要和 S 字段配合在一起才能确定段描述符的确切类型，只有 S 字段的值确定后，type 字段的值才有具体意义。**

![段描述符的type类型](/home/xiaoyao/图片/截图/段描述符的type类型.png)

5.段描述符的第 13～14 位是 DPL 字段，即描述符特权级。两位能表示 4 种特权级，分别是 0、1、2、3 级特权，数字越小，特权级越大

6.段描述符的第 15 位是 P 字段，Present，即段是否存在。如果段存在于内存中，P 为 1，否则 P 为 0。

7.段描述符的第 20 位为 AVL 字段，从名字上看它是 AVaiLable，可用的。

8.段描述符的第 21 位为 L 字段，用来设置是否是 64 位代码段。L 为 1 表示 64 位代码段，否则表示 32位代码段。

9.段描述符的第 22 位是 D/B 字段，用来指示有效地址（段内偏移地址）及操作数的大小。指定“操作数”的大小，也就是对“指令”来说
的，与指令相关的内存段是代码段和栈段，所以此字段是 D 或 B。

- 对代码段来说，是D，若D=0,表示有效地址和操作数都是16位，指令有效地址用IP寄存器。若D=1,32位，有效地址用EIP寄存器。
- 对栈段来说，是B，若B=0,使用sp寄存器，栈的起始地址是16位寄存器的最大寻址范围，0xFFFF;若B=1,使用esp寄存器，栈的起始地址是32位寄存器，0xFFFFFFFF。

这些描述符全部放在GDT全局描述符表中。

GDT位于内存中，需要专门的寄存器指向他。 GDTR，即 GDT Register，专门用来存储 GDT 的内存地址及大小。GDTR 是个 48 位的寄存器。

![GDTR](/home/xiaoyao/图片/截图/GDTR.png)

现在段寄存器中存的是叫选择子的东西，选择子**基本上**是一个索引值，用此索引值去GDT中寻找相应的段描述符。

![段选择子](/home/xiaoyao/图片/截图/段选择子.png)

