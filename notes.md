## 第0章比较有意思的东西

1.**学习一门知识如果无止境地刨根问底下去，虽然会对底层科学更加清晰，但是这对于上层知识的学习非常不利，所以当我们在学习上层知识的时候，我们需要一个假设，假设底层的有些东西是规定的。**

就比如说OS，我们不必纠结硬件电路内部是如何工作的，我们只要认为给硬件一个输入硬件就会给我们一个输出，就是这样。

学习其他知识也是一样，刚开始学习上层的时候就应该假设底层的知识就是按照那样的工作的，在学习过程中如果对底层知识更加感兴趣的话可以继续向下深挖，但是不管在哪一个层面学习，都要学会抽象，掌握这种抽象能力可以有助于我们更好的学习！

2.写OS的时候，哪些需要人为实现

首先需要明确的是计算机是一个很大的系统，所谓系统就是由各个部分组成的，而每个模块部分都有自己的功能，他们各司其职，将自己负责的工作任务交给下一个模块部分，这样就可以分层完成一项功能了。

**其实这里也体现出了分层抽象的重要性！！！每一层抽象只需要负责该层抽象的功能即可。**

另外OS能做什么，还是取决于硬件的一级支持，如果硬件都不支持的话，所有都是白搭。

3.软件控制硬件的方式

访问外部硬件有两个方式：

- 将某一个外设的内存映射到一定范围的主机内存中，CPU通过地址总线访问该主机内存区域的时候会落到外设的内存中，这种映射方式让CPU访问外设的内存就像访问主板上的物理内存一样。
- 外设通过IO接口与CPU通信，CPU访问外设，将相关信息写入到IO接口中的寄存器中，也就实现了对于外设的访问。

4.用户态和内核态是相对于CPU来讲的，是指CPU运行在内核态（特权0级）还是用户态（特权3级）。

用户进程陷入内核态是指：由于内部或者是外部的中断发生，当前进程被暂时终止执行，他的上下文被内核中断程序保存起来，紧接着在特权级0下开始执行内核的相关代码，内核相关代码执行完之后又会回到用户态下。

5.x86平台的处理器是必须要使用分段机制来访问内存的，所以在这种架构下，x86平台的处理器才提供了段寄存器等硬件设备。

程序代码中的段和内存中的段本质上是一回事。程序中有哪些段？内存中有哪些段？

程序中的指令都是紧挨着的，彼此之间没有空隙，程序中的对齐会让数据段中的数据之间产生很多的0，数据与数据之间产生了很多的空隙。

指令是由操作码和操作数组成的，指令的大小是由实际指令的操作码决定的，CPU在译码阶段拿到操作码之后就知道了实际指令所占的大小，就可以算出下一条指令的地址了。

在最开始的8085汇编编程中，并没有分段的体现，可以任意在内存的任何地方定义数据大小，但是8086引入了这种分段，将数据部分和代码部分全都分开了，这样做的好处其实有三点：

- **可以为不同的段赋予不同的属性**

  数据必须有可写的属性，代码段不能够被修改所以不能有可写的属性

- **提高了CPU内部缓存的命中率**

  CPU内部都有缓存机制，具体原理我不是很清楚，大概是可以利用程序的局部性原理，使得程序的运行速度会变得更快。后续感兴趣的话可以去了解一下。

- **节省了内存**

  当一个程序的多个副本同时运行的时候，只需要把一个代码段共享就可以了，不需要重复写代码。

**现在来看一个有意思的问题：既然每一个段都有不同的属性，那这个属性是谁给添加上去的呢？又是谁根据属性保护程序的呢？**

**首先是CPU提供的原生支持，CPU中有一个全局描述符表GDT，里面存储的是段描述符，段描述符有段的属性位，S字段和TYPE字段的组合可以组合出来段的各种属性。**

**其次就是OS来填这张表，OS来设置好GDT的相关项，在段描述符中指定段的位置，大小以及最重要的相关属性。**

**除了他们之外还有编译器的功劳，编译器负责挑选出数据的属性，从而根据属性将程序片段进行分类，他并没有为各个段添加额外的属性信息。**

**在执行指令的时候，会根据段的属性来判断指令的行为，若有返回则发生异常。（想起来在线程debug的时候，我在用户线程调用了内核代码的函数，结果报了GP错误，就是因为段的问题，因为用户程序的代码段属性和内核部分的代码段属性有差别，CPU在跳转到内核中执行指令的过程中会对段的属性进行相应的检查，检测出了错误，所以并不会执行内核部分的代码）**

**这里其实体现出了牛人的牛逼之处，是由编译器，OS，CPU三个配合在一起检测出指令中的违规行为。**

6.在实模式和保护模式下，访问内存的方式略微有一点区别，**但是他们都遵循一个大的原则：段基址+偏移地址。**

![简单的地址问题](/home/xiaoyao/desktop/TinyOS/photos/简单的地址问题.png)

7.段重叠：各个段的基址会不同，在不同段中通过不同的段偏移值可以访问到相同的数据，其实就是段发生了重叠。

8.在32位CPU中，无论是在16位的实模式还是32位的保护模式，用的段寄存器都是同一组，而且所有的段寄存器都是16位宽。

9.为什么linux系统中的应用程序不能在windows系统下运行？列举几个原因：

两个系统中的可执行程序的格式不同，linux中的elf格式，elf文件头中section,segment,程序入口等信息；windows中的是PE格式（可移植的可执行文件），那移植的平台肯定要和window相匹配。

另外两个系统的API不同，linux中API是系统调用，通过0x80这个中断实现的，而windows中的API是存放在动态链接库文件中的，也就是 Windows 开发人员常说的 DLL，即 Dynamic Link Library 的缩写。LL 是一个库，里面包含代码和数据，可供用户程序调用，DLL 不是可执行文件，不能够单独运行。

linux和window获取系统资源的方法也是不一样的，所以显然也不可以在windows中运行。

除了上面两个原因之外，还与编译器，标准库等相关。

10.全局变量放在数据段，可以保证任何人在任何情况下都可以访问。但是局部变量只能放在栈段中，没必要放在数据段供所有人访问，在函数调用的时候，为参数在栈中分配内存，函数调用返回的时候再去释放栈中的内存。

11.高级语言为了通用性等等需要兼顾的东西比较多，往往需要加入一些额外的代码，因此编译出来的汇编代码比较多，举个例子，c编译器在编译的时候会经过预处理，编译，链接的过程，这个过程执行完之后可执行代码就不仅仅是我们在.c文件中写的那一点点了。所以如果通过汇编直接写一些功能会更加直接。

12.先有语言还是先有编译器这个鸡生蛋，蛋生鸡问题

首先肯定的是先有的编程语言，先是设计好语言的规则，然后编写能
够识别这套规则的编译器，否则若没有语言规则作为指导方向，编译器编写将无从下笔。

13.编译型程序和解释型程序还是有很大区别

解释型语言也称为脚本语言，他们本身就是文本文件，是脚本解释器的输入，也就是说脚本中的代码并没有上过CPU执行过，在CPU的眼中只看得见脚本解释器，CPU只会调度该解释器。这些脚本代码看似在按照开发人员的逻辑执行，本质上是脚本解释器在时时分析这个脚本，动态根据关键字和语法来做出相应的行为。

而编译型语言编译出来的程序，运行时本身就是一个进程。它是由操作系统直接调用的。也就是由操作系统加载到内存后，操作系统将 CS：IP 寄存器指向这个程序的入口，使它直接上 CPU 运行。

14.解释一下大端和小端字节序

大端字节序：数值的低字节放在内存的高地址处，数值的高字节放在内存的低字节。

小端字节序：数值的低字节放在内存的低地址，数值的高字节放在内存的高地址。

常见 CPU 的字节序如下：

（1）大端字节序：IBM、Sun、PowerPC。

（2）小端字节序：x86、DEC。

ARM 体系的 CPU 则大小端字节序通吃，具体用哪类字节序由硬件选择。

15.BIOS中断，DOS中断，linux中断三者之间的区别

在计算机系统中，无论是在实模式，还是在保护模式，在任何情况下都会有来自外部或内部的事件发生。如果事件是来自CPU内部的话就称为异常，即 Exception。

首先来看看BIOS中断，BIOS 中断调用的主要功能是提供了硬件访问的方法，该方法使对硬件的操作变得简单易行，可以通过此中断来实现对硬件的访问，发出中断信号之后，BIOS中断处理程序来操作硬件，我们也可以不通过BIOS来操作硬件，只要知道硬件相关的寄存器端口的话也可以对硬件进行相关操作。

接下来看看DOS中断，DOS 是运行在实模式下的，故其建立的中断调用也建立在中断向量表中，只不过其中断向量号和 BIOS的不能冲突。

l**inux中断通过int 0x80指令进入中断程序之后再根据eax寄存器的值来调用不同的子功能函数。如果是在实模式下，会自动访问中断向量表，如果是在保护模式下，会自动访问中断描述符表。**

16.来看看section和segment的区别

section 称为节，是指在汇编源码中经由关键字 section 或 segment 修饰、逻辑划分的指令或数据区域。

segment 称为段，是链接器根据目标文件中**属性相同的多个 section 合并后的 section 集合**，这个集合称为 segment，也就是段。

**链接器最终把目标文件链接成可执行文件，因此段最终诞生于可执行文件中。**

17.看一下魔数这个诡异的数字

魔数其实也就是神奇数字，他被用来为极为重要的数据定义标签，用独特的数字唯一标识该数据。

像MBR中最后两个字节的内容是0x55和0xaa，就是用这两个魔数来表明这个扇区中有可加载的程序，BIOS就使用他来校验该数据是否可引导。

18.操作系统是如何识别很多的文件系统的

一个硬盘上可以有多个分区，而每一个分区的格式又可以不同。像linux就可以识别ext2,ext3,ext4，那他是怎样识别的呢？

其实这也是魔数的作用，文件系统也有自己的魔数。各个分区都有自己的超级快，超级快中记录了此分区的相关信息，其中就有文件系统的魔数，一个文件系统对应一个魔数，这样OS也就可以识别出文件系统的不同类型了。

19.指令集，微架构，编程语言来看看

指令集顾名思义就是指令的集合。

目前世面上的指令集：CISC和RISC。

CISC意为复杂指令集计算机，这套指令非常复杂，因为他是最早出现的指令集，当时的编程人员开发程序的时候希望汇编语言越强大越好，尽量多一些指令，尽量一条指令做更多的事情，所以指令越来越多，越来越复杂，另外CISC是Intel旗下的指令，Intel有向前兼容的优点，这也是指令越来越复杂的一个原因。

RISC就是精简指令集计算机啦。根据二八定律，指令集中 20%的简单指令占了程序的 80%，而指令集中 80%的复杂指令占了程序的 20%。根据这个特性，处理器及指令集被重新设计，保留了那些基本常用的指令，减少了硬件电路的复杂性，而且指令采用了定长编码，这样译码工作更加容易了。

补充一点小常识：
我们常用的 CPU 是 Intel 和 AMD 公司的产品，它们用的指令集便是基于 CISC 思想的 x86。AMD 的 x86指令架构是 Intel 授权给他们的，为区别于此，Intel 在官方手册上称自己的指令集为 IA32。
虽然 AMD 采用的也是 x86 指令集，但 Intel 可没把硬件实现方法也告诉 AMD，否则 AMD 的 CPU 和Intel 的 CPU 不就完全一样了吗，人家 Intel 也不肯呢。

**指令集是一套约定，里面规定的是有哪些指令、指令的二进制编码、指令格式等。**

如何实现这套约定，这是硬件自己的事。打个比方，这就像和朋友约好了在某餐厅吃饭，咱是坐车去，还是走着去，这是咱们的事，与吃饭是无关的。

说白了，在 Intel 的 CPU 上运行的软件也能够在 AMD 的 CPU 上运行，原因就是它们共用了同用一套指令集，也就是对二进制编码
达成了共识。它们面对相同的需求，可能采取了不同的行动，但都完成了任务。

比如机器码是 b80000，Intel的 CPU 经过译码，知道这是将 0 赋值给寄存器 ax，相当于汇编语言 mov ax，0。AMD 的 CPU 在译码时，也得将此机器码认为是将 0 赋值给寄存器 ax。至于它们在物理上是怎么将 0 传入寄存器 ax 中的，这是它们各自实现的方式，与指令集无关。**它们各自CPU实现的方式，就叫微架构。**

**总结一下，指令集是具有一套指令编码，微架构是指令集的物理实现方式。**

为什么咱们自主研发的 CPU 还要用人家国外的指令集？就不能也研发出一套指令集吗？能倒是能，不过语言不通用。就像我自己可以发明一门语言，语言本身没什么问题，**问题是我用自己发明的语言和别人交流，谁听得懂呢，谁又愿意去学这门语言呢**？大家都很忙，不通用的东西没人愿意花精力去学。如果龙芯也自立门户创造新的指令集，**那有谁愿意给它写编译器呢？即使有了编译器，操作系统也要重新编译发布，应用程序也要重新编译发布，指令集背后不仅是个计算机生态链，更重要的是全球经济链。**

所以在全球化的过程中，我们其实只要拥有能够设计并制造出CPU的能力就好了，上层的指令集我们完全可以采用通用的指令集，至于底层的微架构我们可以有自己的实现。拥有了这种能力，在某些方面我们也就不会受制于人，也就在某些领域不会被人卡脖子了。

20.库函数是用户进程与内核桥梁

我们想要使用的一些基本功能，库函数都已经帮助我们实现了，我们只需要调用函数就可以。我们在程序中简单地一句 include <标准头文件>之所以有效，是因为**编译器提供的 C 运行库**中已经为我们准备好了这些**标准函数的函数体所在的目标文件**，在**链接时默默帮我们链接上**了。

**操作系统有自己支持、加载用户进程的规则**，而 C 运行时库是针对此操作系统的规则，为了让用户程序开发更加容易，用来支持用户进程的代码库。

用户进程要与 C 运行时库的诸多目标文件链接后合并成一个可执行文件。

C 运行时库作用如其名，是提供程序运行时所需要的库文件，而且还做了程序运行前的初始化工作，所以即使不包含标准库文件，链接阶段也要用到 c 运行时库。

用户程序可以不和操作系统打交道，但如果需要操作系统的支持，必须要通过系统调用。

**尽管系统调用封装在库函数中，但用户程序可以直接调用“系统调用”，不过用库函数会比较高效（这里还有点意思，后续有时间了可以看看！！！）**

21.MBR,EBR,DBR,OBR都是什么呢

MBR是主引导记录，他的引导扇区中存储着引导程序。BIOS知道MBR在0盘0道1扇区，因此他会将MBR中的引导程序加载到物理地址0x7c00，然后跳过去执行引导程序。

引导扇区中除了有引导程序之外，还有64B大小的分区表，里面是分区信息，4个分区就是次引导程序的候选者，次引导程序其实就是操作系统加载器。

主引导程序的任务就是把控制权交给操作系统加载器，由该加载器完成OS的自举，最终将控制权交给操作系统内核。

为了让MBR知道哪一个分区有OS,同样在分区的时候，就使用分区工具将该分区设置为活动分区，设置活动分区的本质就是把分区表中该分区对应的分区表项中的活动标记设置为0x80。主引导程序在分析分区表的时候通过辨认活动分区的0x80，找到之后，就将CPU的控制权交给此分区上的引导程序。

内核加载器的位置也是固定的，在各个分区最开始的扇区，因此该扇区称为操作系统引导扇区，其中的引导程序（内核加载器）称为操作系统引导记录OBR，此扇区也称为OBR引导扇区。

在OBR引导扇区的前3个字节存放了跳转指令，该跳转指令将CPU带入了操作系统引导程序，从此便是开始内核代码了。

但是OBR中的开头跳转指令跳转的目标地址并不固定，这是由创建的文件系统决定的。

DBR其实是DOS操作系统的引导记录（程序）。

具体EBR的信息可以看后面磁盘分区部分的笔记。

![MRB,EBR,OBR的关系](/home/xiaoyao/desktop/TinyOS/photos/MRB,EBR,OBR的关系.png)

MBR 位于整个硬盘最开始的块。

EBR 位于每个子扩展分区，各子扩展分区中只有一个逻辑分区。MBR 和 EBR 位于分区之外的扇区，而 OBR 则属于主分区和逻辑分区最开始的扇区，每个主分区和逻辑分区中都有 OBR 引导扇区。

## 第2章：编写MBR引导程序

最初的8086有20根地址线，所以可以访问1MB的空间，在1MB的内存空间中他被划分成了多个部分：

![实模式下的1MB内存空间](/home/xiaoyao/desktop/TinyOS/photos/实模式下的1MB内存空间.png)

在开机的一瞬间，CPU将cs：ip强制初始化成0xf000:0xfff0,此地址便是BIOS的入口地址。

0xffff0这个地址存放着一条指令（因为只有16B大小），该指令的内容是跳转到BIOS程序的入口处。也就是说真正的BIOS程序不在这里。

BIOS的主要功能：

- 硬件自检
- 建立一些需要用到的数据结构与中断向量表
- 校验启动盘中位于0盘0道1扇区（**在CHS方式中扇区的编号是从1开始的，不是0，所以这里其实也就是0盘0道0扇区，也就是磁盘最开始的那个扇区**）的内容，校验这里是不是放着主引导记录MBR并校验这个扇区的最后两个字节是不是0x55与0xaa
- 校验完之后，将该扇区的内容**加载到内存0x7c00**处（至于为什么是这个地址其实是有历史原因的），加载完毕之后跳转过去执行此程序，**此程序也就是最后的MBR**

**MBR的大小必须是512字节，这是为了保证0x55和0xaa这两个魔数恰好出现在该扇区的最后两个字节处。**

图中内存地址 0～0x9FFFF 的空间范围是 640KB，这里的地址对应到了DRAM，也就是插在主板上的内存条。

有几个疑问：**为什么是对应到了 DRAM，难道不是直接访问到我的物理内存DRAM 吗？难道我的内存条不是全部的内存？还可以访问到别处吗？**

自己可以这样理解：在计算机中并不是只有内存条需要通过地址总线访问，还有一些外部设备同样需要通过地址总线来访问，所以在地址总线可以访问的地址空间中预留一些地址空间给这些外设。

CPU给地址总线提交一个地址，地址总线中的分配电路根据此地址的范围，决定在哪一个存储设备中读取数据并且映射一个存储设备的存储单元。这个存储单元要么在ROM中，要么在某一个外设的内存中，要么在物理内存条中。

**Q:在存储单元确定好之后，读取存储单元的相应内容，那把这些读取到的这些内容放在哪里呢？**



### 汇编中的一些语法知识点：

$表示的是当前行的地址，$$表示的是本section的地址，这两个都是伪指令。

vstart表示本程序在编译的时候，告诉编译器将起始地址设置成vstart的值。

```asm
mov ah, 3
; 输入: 3 号子功能是获取光标位置,需要存入 ah 寄存器
mov bh, 0
; bh 寄存器存储的是待获取光标的页号
int 0x10
; 输出: ch=光标开始行,cl=光标结束行
; dh=光标所在行号,dl=光标所在列号
```

重新看到页，忘记了他是什么。

显示器有很多种模式，如图形模式、文本模式等，在文本模式中，又可以工作于 80×25 和 40×25 等显示方式，默认情况下，所有个人计算机上的显卡在加电后都将自己置为 80×25 这种显示方式。80×25 是指一屏可以显示 25 行、每行 80 列的字符，也就是 2000 个字符。

但由于**一个字符要用两字节来表示**，低字节是字符的 ASCII 编码，高字节是字符属性，故显示一屏字符需要用 4000 字节（实际上，分配给一屏的容量是 4KB），这一屏就称为一页，0 页是默认页。

**dd命令是用于磁盘操作的命令，可以用此命令来操作磁盘上的任何一个扇区。具体的命令如果想要使用可以看手册或者查资料**

## 第3章：完善MBR

当我们想问一个问题的时候，不知道问什么，但是又不知道哪里不会不知道从何问起，其实是哪里都不懂！根本没有掌握知识，能问出问题的人才是掌握的差不多的人。

地址是描述各种符号在源程序中的位置，当我们在编译的时候如果没有加-g参数不会保留编译信息，在使用gdb调试的时候如果没有导入符号表，完全不能调试。

编译器的工作就是给各种符号编址，将源代码中的每一个符号都按照本硬件平台的特性分配空间。分配的地址就是各个符号相对于文件开头的偏移量。

**了解一个东西的概念，可以从这个东西可以干什么来了解。**

### CPU的工作原理：



实模式下的一些指令：

**直接，间接，绝对，相对，远，近这6组概念区分**

实模式下的call

直接：目标函数的地址（操作数）直接给出，是个立即数。

间接：目标函数的地址没有直接给出，地址要么在寄存器中要么在内存中。

绝对：目标函数的地址是绝对地址，是段内偏移值。

相对：目标函数的地址是相对地址，相对当前指令的偏移值。（我理解的还有一层是相对于当前指令下一条指令的偏移值）

远：段间，目标函数和当前代码段不是一个段。

近：段内，目标函数和当前代码段是一个代码段。

前两种是近调用，后两种是远调用

- 16位实模式相对近调用
- 16位实模式间接绝对近调用
- 16位实模式直接绝对远调用
- 16位实模式间接绝对远调用

实模式下的jmp

- 16位实模式相对短转移
- 16位实模式相对近转移
- 16位实模式间接绝对近转移
- 16位实模式直接绝对远转移

**大概说一下实模式：在实模式中，用户程序和OS可以说是同一特权级的程序，因为在实模式中没有特权级，也就是说此时的硬件还没有支持特权级，他处处和OS平起平坐，所以可以执行一些具有破坏性的指令。由于完全没有保护性可言，所以往后发展了保护模式。**

### 对显卡的操作

CPU 和外设之间的就是 IO 接口，以后CPU有什么事和他接触就可以了，你像速度不匹配，缓冲区之类的，全都由他来搞定。

如果是串行设备，CPU 就同串行接口通信，把数据发给它后，数据再经由串行接口发给串行设备，串行设备有了反馈后，把数据发送给串行接口，再经串行接口返回给 CPU，并行设备也是如此。

**显卡就是一种IO接口，他是用来驱动显示器的。**

**显存是显卡提供的，显卡的工作就是不断读取显存中的内容，然后将其发送到显示器。（如果我们知道显存的地址的话，完全可以直接将数据写入到显存中，这样就可以让显卡在我们的控制下工作了）**

显卡可以让显示器工作在三种模式：文本模式，黑白图形模式，彩色图形模式。

在计算机使用层面，我们不用关注显卡具体是如何将像素拼凑到一起的，我们只需要知道：一个字符对应一个字节的编码，只要往显存中写入了这个编码，显卡就知道这是要打印字符，由显卡自己完成像素的拼凑，从而解放了计算机使用者。如果说不是站在计算机使用者的角度的话，而是站在显卡的角度的话，完全就是另外的考虑范畴了。这个编码其实就是ASCII编码：他将所有的字符分成了两大类，一类是不可见字符——控制字符属于这一类，其余的是可见字符。

![显存地址分配](/home/xiaoyao/desktop/TinyOS/photos/显存地址分配.png)

往0xb800处输出的字符会直接落到显存中，显存中有了数据之后显卡就会将数据显示出来。

**另外屏幕上可以显示多少个字符取决于采用的是哪种文本模式了。如果以后有感兴趣的话可以去了解一下。**

屏幕上每一个字符的低字节是字符的ASCII，高字节是字符属性元信息。

![字符及其属性](/home/xiaoyao/desktop/TinyOS/photos/字符及其属性.png)

```asm
mov byte [gs:0x00],'1'    
;把字符1的ascii码写入以gs:0x00为起始，大小为1字节的内存中
```

关键字byte用于指定操作数所占的空间，同类的关键字还有word,dword等，这些关键字都指明了数据需要的存储空间。

### 常用的硬盘操作方法

（具体硬盘相关信息可以看13章中我对硬盘的介绍）

约定个步骤：
（1）先选择通道，往该通道的 sector count 寄存器中写入待操作的扇区数。
（2）往该通道上的三个 LBA 寄存器写入扇区起始地址的低 24 位。
（3）往 device 寄存器中写入 LBA 地址的 24～27 位，并置第 6 位为 1，使其为 LBA 模式，设置第 4位，选择操作的硬盘（master 硬盘或 slave 硬盘）。
（4）往该通道上的 command 寄存器写入操作命令。
（5）读取该通道上的 status 寄存器，判断硬盘工作是否完成。
（6）如果以上步骤是读硬盘，进入下一个步骤。否则，完工。
（7）将硬盘数据读出。

**MBR只有512字节大小，在这个大小的空间中没有办法完全为内核准备好环境，更没有办法将内核加载到内存中运行。所以我需要在另一个程序中完成初始化环境以及加载内核的任务，这个程序叫做loader。在loader中要定义一些数据结构（GDT全局描述符表之类的），这些数据结构将来的内核还需要再次使用，所以loader加载到内存中之后不应该被覆盖！！**

**将loader从硬盘中固定的扇区加载到内存固定的地址0x900处，loader（内核加载器）的最终目的就是为了要加载内核。**

Q:这里的loader和前面提到的OBR之间有什么关系？两者都是内核加载器，是用来实现加载内核的方式不同吗？



## 第4章：保护模式入门

在保护模式下很多概念都是CPU硬件原生提供的，所以在编码的时候所有的一些新的东西都是按照CPU的设计来写的，换种说法也就是说CPU必须有了这些东西才能运行。

稍微看一下实模式的不幸：

- 实模式下操作系统和用户程序属于同一特权级，没有区别对待
- 用户程序所引用的地址都是指向真实的物理地址，也就是说逻辑地址等于物理地址
- 用户程序可以自由修改段基址

### 保护模式的几大特点：

1.寄存器的扩展：段寄存器还是16位

内存段变多了，所以寄存器放不下了，使用数据结构——**全局描述符表**来存储信息。

其中的表项称为**段描述符**，用来描述各个内存段的起始地址，大小，权限等信息，**该全局描述符表很大，所以放在了内存中，由GDTR寄存器指向就可以了**。

另外段寄存器中也不会再保存段基址，保存的叫做选择子，“selector”，他其实就是一个索引值，用来索引全局描述符表中的段描述符。

2.寻址扩展

![实模式的寻址](/home/xiaoyao/desktop/TinyOS/photos/实模式的寻址.png)

实模式到保护模式进行了扩展

![保护模式的寻址](/home/xiaoyao/desktop/TinyOS/photos/保护模式的寻址.png)

3.运行模式扩展

4.指令扩展

（1）mul指令：

mul 指令是无符号数相乘指令，指令格式是 mul 寄存器/内存。其中“寄存器/内存”是乘数。

如果乘数是 8 位，则把寄存器 al 当作另一个乘数，结果便是 16 位，存入寄存器 ax。
如果乘数是 16 位，则把寄存器 ax 当作另一个乘数，结果便是 32 位，存入寄存器 eax。
如果乘数是 32 位，则把寄存器 eax 当作另一个乘数，结果便是 64 位，存入 edx：eax，其中 edx 是积
的高 32 位，eax 是积的低 32 位。

（2）push指令：操作数类型有3种，分别是立即数，寄存器，内存。

当压入 8 位立即数时，由于保护模式下默认操作数是 32 位，CPU 将其扩展为 32 位后入栈，esp 指针减 4。

当压入 16 位立即数时，CPU 直接压入 2 字节，esp 指针减 2。
当压入 32 位立即数时，CPU 直接压入 4 字节，esp 指针减 4。
对于通用寄存器和内存，无论是在实模式或保护模式：

- 如果压入的是 16 位数据，栈指针减 2。
- 如果压入的是 32 位数据，栈指针减 4。 

### 段描述符

![段描述符格式](/home/xiaoyao/desktop/TinyOS/photos/段描述符格式.png)

段描述符是8B（64字节）大小，上图只是人为的划分成了两部分，其实是连续的8字节，这样CPU才能读取到正确的段信息。

1.保护模式下地址总线宽度是 32 位，**段基址需要用 32 位地址来表示。**

2.段界限表示段边界的**扩展最值**，即最大扩展到多少或最小扩展到多少。数据段和代码段的扩展方向是向上——地址越来越高，此时的段界限表示段内偏移最大值。栈的是向下——地址越来越低，表示偏移的最小值。

段界限是个单位量，单位要么是字节，要么是4kb。如果 **G 位为 0**，表示段界限粒度大小为 1 字节；如果 **G 位为 1**，表示段界限粒度大小为 4KB字节。

3.CPU眼中，凡是**硬件运行**需要用到的东西都称之为系统段，凡是**软件需要**的东西都称之为数据段。无论是代码还是数据，他们都是软件运行的必须品，只不过借助硬件在硬件上运行，并不属于硬件运行的必须品，所以他们都称为数据。S为1表示数据段，S为0表示系统段。

4.type 字段，该字段共 4 位，用于表示内存段或门的子类型。**type 字段是要和 S 字段配合在一起才能确定段描述符的确切类型，只有 S 字段的值确定后，type 字段的值才有具体意义。**

![段描述符的type类型](/home/xiaoyao/desktop/TinyOS/photos/段描述符的type类型.png)

重点来看一下非系统段的信息，X表示该段是否可执行，代码段时可执行的为1，数据段是不可执行的为0.

E表示扩展方向，1表示向下，0表示向上。

W表示是否可写，1表示可写，0表示不可写。如果对W为0的段进行写入行为，会引发CPU抛出异常。

5.段描述符的第 13～14 位是 DPL 字段，即描述符特权级。两位能表示 4 种特权级，分别是 0、1、2、3 级特权，数字越小，特权级越大

6.段描述符的第 15 位是 P 字段，Present，即段是否存在。如果段存在于内存中，P 为 1，否则 P 为 0。

7.段描述符的第 20 位为 AVL 字段，从名字上看它是 AVaiLable，可用的。

8.段描述符的第 21 位为 L 字段，用来设置是否是 64 位代码段。L 为 1 表示 64 位代码段，否则表示 32位代码段。

9.段描述符的第 22 位是 D/B 字段，用来表示指令中的有效地址（段内偏移地址）及操作数的大小。指定“操作数”的大小，也就是对“指令”来说的，与指令相关的内存段是代码段和栈段，所以此字段是 D 或 B。

- 对代码段来说，是D，若D=0,表示有效地址和操作数都是16位，指令有效地址用IP寄存器。若D=1,32位，有效地址用EIP寄存器。
- 对栈段来说，是B，若B=0,使用sp寄存器，栈的起始地址是16位寄存器的最大寻址范围，0xFFFF;若B=1,使用esp寄存器，栈的起始地址是32位寄存器，0xFFFFFFFF。

一个描述符都进行了相关赋值之后才会放到GDT中去。

GDT位于内存中，需要专门的寄存器指向他。 GDTR，即 GDT Register，专门用来存储 GDT 的内存地址及大小。GDTR 是个 48 位的寄存器。

![GDTR](/home/xiaoyao/desktop/TinyOS/photos/GDTR.png)

lgdt 的指令格式是：lgdt   48 位内存数据

从GDT界限就可以看出GDT 的大小是 16 位二进制，其表示的范围是 2的 16 次方等于 65536 字节。每个描述符大小是 8 字节，故，GDT 中最多可容纳的描述符数量是 65536/8=8192个，即 GDT 中可容纳 8192 个段或门。

现在段寄存器中存的是叫选择子的东西，选择子**基本上**是一个索引值，用此索引值去GDT中寻找相应的段描述符。

![](/home/xiaoyao/desktop/TinyOS/photos/段选择子.png)

（1）在其低 2 位即第 0～1 位，用来存储 RPL，即请求特权级，可以表示 0、1、2、3 四种特权级。

（2）第 2 位是 TI 位，即 Table Indicator，用来指示选择子是在 GDT 中，还是 LDT 中索引描述符。TI为 0 表示在 GDT 中索引描述符，TI 为 1 表示在 LDT 中索引描述符。

（3）高 13 位，即第 3～15 位是描述符的索引值，用此值在 GDT 中索引描述符。

**需要注意的是，GDT中第0个段描述符不可用。段基址在段描述符中，用给出的选择子索引出描述符之后，CPU会自动从段描述符中取出段基址，然后再加上段内偏移地址，最后凑成经典的仿存模式。**

IBM 在键盘控制器上的一些输出线来控制第 21 根地址线（A20）的有效性，故被称为 A20Gate。说白了就是为了兼容之前的产品。

- 如果 A20Gate 被打开，当访问到 0x100000～0x10FFEF 之间的地址时，CPU 将真正访问这块物理内存。
- 如果 A20Gate 被禁止，当访问 0x100000～0x10FFEF 之间的地址时，CPU 将采用 8086/8088 的地址回绕，完全就是8086的仿存模式。

控制寄存器是 CPU 的窗口，既可以用来展示 CPU的内部状态，也可用于控制 CPU 的运行机制。

**进入保护模式之前，需要将打开开关，PE位置1,启动保护模式。**

![](/home/xiaoyao/desktop/TinyOS/photos/CR0寄存器.png)

遇到的bug：

显存段段描述符的高4字节中的16-23位的段基址写的有问题，在1MB的空间中文本模式的显存段基址是0xb8000，所以最后的仿存地址一定要符合这个地址。

结果刚开始的16-23写的是0x00,没写成0x0b，低部分四字节中0-15位的地址正确，就是因为高四字节的内容不正确最后的仿存地址不正确，没有显示正确的结果。

```asm
VIDEO_DESC: dd 0x80000007       ;limit=(0xbffff-0xb8000)/4k=0x7
            dd DESC_VIDEO_HIGH4 ;dpl=0
```

### 流水线

```asm
jmp dword SELECTOR_CODE:p_mode_start
;刷新流水线
```

jmp指令有清空流水线的作用，流水线是 CPU 为提高效率而采取的一种工作方式，CPU 将当前指令及其后面的几条指令同时放在流水线中重叠执行。

**Q:如何理解流水线原理，CPU大概利用流水线是如何进行工作的？**——看自己的计组笔记

使用jmp指令进行是因为有两个问题需要解决：

1.首先段描述符缓冲寄存器未更新，他还是实模式下的值，这里已经正式进入了保护模式了，进入保护模式之后需要正确的寄存器信息。

进入保护模式时，由于段描述符缓冲器中的内容仅仅是实模式下的20位的段基址，很多属性位对于保护模式来说都是错误的值，所以必须要更新段描述符缓冲寄存器。

2.流水线中指令译码错误。

由于在实模式下时，指令按照 16 位指令格式来译码，第 78～82 行既有 16 位指令，又有 32位指令，如果流水线把 32 位指令按照 16 位译码就会出错。

### 内存段的保护

描述内存段的段描述符中有很多属性，都是给CPU来参考的，当有实际动作在这片内存上发生时，CPU用这些属性来检查动作的合法性，从而起到了保护的作用。

#### 向段寄存器加载选择子时的保护

当引用内存段的时候，就必须往段寄存器中加载选择子，为了避免非法引用，处理器会做以下几个方面的检查：

- 首先根据段选择子的值验证段描述符是否越界，这里的越界指的是超过GDT或者LDT的界限
- 检查段的类型是否匹配，大的原则如下：
  - **只有具备可执行属性**的段（代码段）才能加载到 CS 段寄存器中
  - 只具备**执行属性**的段（代码段）不允许加载到除 CS 外的段寄存器中
  - 只有具备**可写**属性的段（数据段）才能加载到 SS 栈段寄存器中
  - 至少具备可读属性的段才能加载到 DS、ES、FS、GS 段寄存器中
- 如果CPU发现有上述规则不符合，检查就不会通过
- 检查段是否存在，通过P来确认，为1表示存在，这时候就可以将选择子载入段寄存器了，同时段描述符缓冲寄存器也会更新为选择子对应的段描述符的内容，随后处理器将段描述符中的 A 位置为 1，表示已经访问过了。如果 P 位为 0，则表示该内存段不存在，不存在的原因可能是由于内存不足，操作系统将该段移出内存转储到硬盘上了。这时候处理器会抛出异常，自动转去执行相应的异常处理程序，异常处理程序将段从硬盘加载到内存后并将 P 位置为 1，随后返回。

#### 代码段和数据段的保护

CPU每次访问一个地址，都要确认该地址不能超过其所在的内存段的范围，更不能落到段的边界上。如果不满足条件就会抛出异常。

#### 栈段的保护

对于向上扩展的段，实际的段界限是段内可以访问最后一个字节

对于向下扩展的段，实际的段界限是段内不可访问的第一个字节

Q:我想知道内核程序和这些段之间的保护是怎样相关联的？

## 第5章：向内核迈进

### 1.获取物理内存容量

### 为什么要获取物理内存？如何获取物理内存？

**BIOS中断获取内存是实模式下的方法，只能在进入保护模式之前调用，为什么不能再进入保护模式之后再调用呢？没有对应的方法吗？**

启用BIOS中断0x15功能

- 子功能0xe820，遍历主机上的全部内存

由于系统内部内存各部分的类型属性不同，此功能就是按照类型属性来划分这片系统内存，每次BIOS只返回一种类型的内存信息。

使用**地址范围描述符（ARDS）**来描述各种内存类型信息。

地址范围描述符的结构（共20个字节，160位）：

![ARDS](/home/xiaoyao/desktop/TinyOS/photos/ARDS.png)

每一次int 0x15之后，BIOS就会返回这么一个结构。

调用前输入：

eax：子功能号

ebx：ARDS的后续值,第一次调用一定要置为0,每次中断返回值后BIOS都会更新此值。

es : di：ARDS缓冲区，BIOS将获取到的内存信息写入到此寄存器指向的内存中。

ecx：ARDS结构的字节大小

edx：固定签名标记0x534d4150，此十六进制数字是字符串 SMAP 的 ASCII 码：BIOS 将调用者正在请求的内存信息写入 ES：DI 寄存器所指向的 ARDS 缓冲区后，再用此签名校验其中的信息

Q：为什么BIOS会按照类型来返回内存信息呢，为什么不去一股脑的返回呢？

A：**这部分内存可能是系统的ROM;系统的ROM可能用到了这部分内存；设备内存映射到了这部分内存；由于某种原因这段内存不适合在标准设备中使用。**

- 子功能0xe801

最大只能识别4G内存。检测到的内存是分别放在两组寄存器中。

<15M的内存以1k为单位，单位数量在ax和cx中记录，两个值一样，实际内存大小是ax✖1024

16M-4G的内存以64k为单位，数量在bx和dx中记录，两个值一样，实际内存大小是bx✖64✖1024

- 子功能0x88

只能识别最大64M的内存大小。



### 2.启动分页机制

### 首先要明确的问题：什么是分页机制？为什么要采取分页机制？如何实现分页机制？

为什么要采用分页机制呢？

找个情景看看：

![分页的情景](/home/xiaoyao/desktop/TinyOS/photos/分页的情景.png)

显然进程D的数据不可以全部加载到内存中去。

这个问题的本质是在目前内存中只分段的情况下，CPU认为线性地址等于物理地址，也就是说PC中的地址CPU拿到之后就去物理地址访问，**而线性地址本身也是连续的，所以物理地址也必须是连续的，但是在实际的物理内存中可用的物理地址不是连续的，所以理论上就不可以把这部分数据加载到内存中。**

**那理论上如果线性地址连续，但是物理地址不连续，这样不就可以把D全部加载到内存中去了**吗：换句话说D的一部分在20M中，另一部分在15M中。

什么是分页机制呢？

**思想**就是：通过映射将连续的线性地址与任意的物理内存地址相关联，逻辑上连续的线性地址在对应的物理地址上可以不连续。

我们通过段部件拿到了线性地址，如果不开启分页，CPU就认为是物理地址直接送上地址总线；如果开启分页，此地址不应该被送上地址总线，CPU自动在页表中查找，找到这条指令或者是数据对应的物理地址。

![分页机制](/home/xiaoyao/desktop/TinyOS/photos/分页机制.png)

分页机制下OS加载用户进程的大致流程：

每次加载一个进程，像之前说的OS和编译器合作制定好自己进程中各段的起始范围，在进程自己的虚拟地址空间中寻找可以分配的内存段，此时并没有真正的写入内存。在分页机制下，将大小不等的段拆分成大小相等的页，也可以**理解成小内存块**。代码段和数据段在逻辑上被拆分成以页为单位的小内存块，然后OS为这些虚拟内存页分配真实的物理内存页，查找到可用的物理内存之后然后在页表中登记这种映射。

CPU中一页是4K大小，4G内存空间被划分成4G/4K=1M页

分页机制打开前要将**页表地址**加载到控制寄存器 cr3 中

![一级页表转成物理地址过程](/home/xiaoyao/desktop/TinyOS/photos/一级页表转成物理地址过程.png)

例子：在一级页表的情况下，mov ax，[0x1234]来看，先将地址送入段部件得到一个线性地址，然后将线性地址送入页部件，经过转化得到其对应的物理地址。（熟悉一下顺序）

OS中肯定不能使用1级页表，这样的话就相当于4G虚拟地址中每一个虚拟地址都会有一个页表项，一个页表项4B，所以会占内存16G，这种方式是不可取的。

采取2级页表可以解决这个问题。

![二级页表转化过程图](/home/xiaoyao/desktop/TinyOS/photos/二级页表转化过程图.png)

每一个进程都有自己的页表，各自的页表记录着各自的虚拟空间中使用的情况，另外在任务切换的时候页表也需要同时切换。

**Q:每一个进程都有自己的二级页表吗？还是说每一个进程都只有一个页表，所有的页表都记录在一个页目录中？**



关键是**cr3寄存器(页目录基址寄存器)**存储的就是页目录物理地址。



![页目录项以及页表项](/home/xiaoyao/desktop/TinyOS/photos/页目录项以及页表项.png)

参数：

- P，Present，意为存在位。若为 1 表示该页存在于物理内存中，若为 0 表示该表不在物理内存中。操作系统的页式虚拟内存管理便是通过 P 位和相应的 pagefault 异常来实现的。
- RW，Read/Write，意为读写位。若为 1 表示可读可写，若为 0 表示可读不可写。
- US，User/Supervisor，意为普通用户/超级用户位。若为 1 时，表示处于 User 级，任意级别（0、1、2、3）特权的程序都可以访问该页。若为 0，表示处于 Supervisor 级，特权级别为 3 的程序不允许访问该页，
  该页只允许特权级别为 0、1、2 的程序可以访问。
- PWT，Page-level Write-Through，意为页级通写位，也称页级写透位。直接设置为0就可以了。
- PCD，Page-level Cache Disable，意为页级高速缓存禁止位。若为 1 表示该页启用高速缓存，为 0 表示禁止将该页缓存。这里咱们将其置为 0。
- A，Accessed，意为访问位。若为 1 表示该页被 CPU 访问过啦，所以该位是由 CPU 设置的。
- **D，Dirty，意为脏页位。当 CPU 对一个页面执行写操作时，就会设置对应页表项的 D 位为 1。此项仅针对页表项有效，并不会修改页目录项中的 D 位。**
- PAT，Page Attribute Table，意为页属性表位
- G,Global，意为全局位。此 G 位用来指定该页是否为全局页，为 1 表示是全局页，为 0 表示不是全局页。若为全局页，该页将在高速缓存 TLB 中一直保存，给出虚拟地址直接就出物理地址。清空 TLB 有两种方式，一是用 invlpg 指令针对单独虚拟地址条目清理，或者是重新加载 cr3 寄存器，这将直接清空 TLB。
- AVL，表示可用，不用管这个位。

要求页目录表所在的地址要求在一个自然页内，也就是4k的整数倍。

### 操作系统与用户进程之间的关系以及页面布局

用户进程应该是共享OS的，所以设计的页表也应该满足共享，让所有用户进程的3G-4G的虚拟地址空间都指向同一个OS，也就是说指向的是同一片物理页地址，这片物理页就是OS的实体代码。

**换句话说就是要保证虚拟地址空间3G-4G对应的页表项中记录的物理页地址是相同的就行了。**

自己设计页目录表和页表的内存布局：总个1024个页表，每一个页表占4K。页目录表的物理地址是0X100000，第一个页表的物理地址是0x101000。

 ![布局](/home/xiaoyao/desktop/TinyOS/photos/布局.png)

设计的将第0项和第768项页目录项指向同一个页表，都是第一个页表，在第一个页表中我们只分配了1MB的空间，剩余3MB并没有分配。分配的标志就是PTE中有具体的值，前20位是物理地址，后12位是属性值。

设计的将第1023个页表中填充的是页目录的实际物理地址。

设计的将第768-1022之间的页目录项指向的是内核空间需要的页表，从第2个页表开始，一共254个页表，到256结束。（此时只是暂时划分了区域，还没有将具体的PTE的值填入到相应的页表项中，还不算真正分配的内存空间）

**此处把页目录表中有关内核的页目录项写满，目的是为了将来的用户进程准备，使得所有的用户进程共享内核空间，每个用户进程的页目录表中第768-1022个页目录项都是与其他进程相同的，所以为用户进程创建页表的同时应该把内核页表在页目录项中所属的768-1022个页目录项相应的复制过来。**

将来内核运行在3G以上的空间，打印功能也应该在内核中实现，用户肯定不可以直接操作显存，所以显存的段基址也要改为3G以上才可以。

我们设计的低端 1MB的虚拟内存空间，其与物理内存 1MB 是一一对应的，在 0～1MB 之间，访问其中任何一个虚拟地址，最终都转换成与其等值的物理地址。

### 使用虚拟地址访问页表

现在已经完成了数据的虚拟映射访问。我们访问任何的虚拟地址都需要通过页表了，但是页表也是一个动态的结构，有时候需要添加页表，有时候需要减少页表，需要我们动态的调整。**如何通过虚拟地址访问到页表并且修改页表属性是一个问题？**

首先cr3寄存器中存储的是页目录表的物理地址。

虚拟地址的高10位用来访问页目录表中的目录项，虚拟地址的中间10位用来在页表中定位一个页表项，虚拟地址的低12位是最后物理地址的偏移量。

![虚拟地址和物理地址的映射](/home/xiaoyao/desktop/TinyOS/photos/虚拟地址和物理地址的映射.png)

总结一下使用虚拟地址获取页表中各个数据类型的方法：

- 获取页目录表的物理地址

  让虚拟地址的高20位和低12位分别为0xfffff和0x000,这样就会通过页目录表的映射，得到页目录表的物理地址，也是页目录表中第0个页目录项自身的物理地址。

- 访问页目录中的页目录项——获取页表地址

  让虚拟地址的高20位和低12位分别是0xfffff和xxx，其中xxx是页目录项的索引×4的积

- 访问页表中的页表项

  虚拟地址高10位为0x3ff，目的是获取页目录表物理地址

  中间10位是页表的索引

  低12位是页表内的偏移地址，用来定位页表项，他必须是×4之后的结果

频繁的查找也不是办法，所以会有快表TLB。

TLB中存放的是虚拟地址页框和物理地址页框的映射关系，是一个缓存机制，每次查找会先从这里面查找。

### 3.加载内核

此时我们写的程序是脱离操作系统的程序，所以必须自己指定程序的入口地址。

**标准库中有很多优化策略，通过标准库访问系统资源比直接使用系统调用访问系统资源更加高效。**

虽然目前第一个内核程序（简单的while循环）非常简洁，和电脑中真正的内核相差非常多，但是目的有两个：

- 演示如何加载内核
- 演示elf格式的文件解析

操作系统加载用户程序的时候无非就是jmp或者call，需要我们显示的指明地址在哪里。

之前的所有地址都是固定的，方法非常不灵活，需要调用方和被调用方提前约定好调用地址。

有没有一种灵活的方法让程序的加载地址不那么固定呢？——有，当然有，每个程序是单独运行的，所以可以在程序的头部设置一段空间，在这个空间中写入程序的入口地址，调用的时候规定从程序的相应空间中将程序的入口地址读出来，**紧接着把程序体整体复制到执行文件的入口地址（这个入口地址应该之前设置的一样）**，然后再加载到执行文件的入口地址执行，jmp过去就可以了。

程序的文件头就记录着这部分信息，记录着描述程序布局等信息——也称为元信息。

还有一个问题就是程序头我们完全可以自己指定，只要保证最后按照我们的格式来解析就可以。

但是这样毕竟不通用，为了通用性最后就采用了gcc生成的elf文件格式。

生成可执行文件的过程：**源程序编译成目标文件，再将目标文件链接成二进制可执行文件。**

目标文件也称为待重定位文件，重定位文件就是指文件里面用到的符号还没有安排地址。所以一律在链接阶段对符号进行重定位。

**链接可以指定最终生成可执行文件的起始虚拟地址。**

链接器规定，默认只把名为_start 的函数作为程序的入口地址，即默认的 entry symbol 是_start，除非另行指定。

#### elf——Executable and Linkable Format，可执行链接格式（文件格式）

程序中最重要的就是段和节了，他们是真正的程序体。多个节经过链接之后就被合并为一个段了。

段和节的信息也是用header来表示的。因为程序中段和节的数量以及大小不固定，专门找了个数据结构存储他们，就是程序头表（program header table）和节头表(section header table)。两个既然都是表，这说明表里面存储的是多个程序头 program header 和多个节头 section header 的信息。

程序头表其实就是用来描述段的，也可以称作段头表。

用一个固定大小的数据结构来描述程序中程序头表和节头表的大小以及位置信息，我们称为ELF header——位于文件最开始的地方，并且具有固定大小。

![elf header](/home/xiaoyao/desktop/TinyOS/photos/elf header.png)

程序头表中的每个条目是用来描述各个段的信息的，来看每个条目的数据结构。

程序头表中描述的段是位于磁盘上的程序中的一个段，也就是磁盘上的程序文件中的内容格式，并不是之前的内存中的段。

![program header](/home/xiaoyao/desktop/TinyOS/photos/program header.png)

![ELF文件格式布局](/home/xiaoyao/图片/截图/ELF文件格式布局.png)

简单的第一个内核文件main.c编译成elf目标文件之后，查看部分相关信息。

具体的在文件中二进制表现形式如图：

![每一个字节的表现形式](/home/xiaoyao/desktop/TinyOS/photos/每一个字节的表现形式.png)

左边的是在文件中的偏移量，**中间的是文件中的内容**，按照16进制输出，两个16进制是一个字节，一行共有16个字节。

7F，45,4c,46分别是e_ident[0]，e_ident[1],e_ident[2],e_ident[2]的内容，其他的会依次类推。

**思考：我们在程序中的结构体等变量最终都是通过编码来在文件中存储的，只要我们找准文件偏移量就可以将文件中的这些数据读取出来，然后再进行相应的处理。**

我们还可以通过readelf命令来具体查看相关信息：

![readelf命令](/home/xiaoyao/desktop/TinyOS/photos/readelf命令.png)

-e 参数相当于'-h' + '-l' + '-S'，能让大家看到 elf header(file header)、program header 和 section header。

可以通过这个命令来简单的看看elf文件中的相关信息。

#### 将内核载入内存

- 加载内核：把内核文件加载到内核缓冲区，意思是把内核从硬盘上拷贝到内存中，并不是运行内核代码。
- 初始化内核：**在分页之后，将加载进来的elf内核文件安置到相应的虚拟内存，然后跳过去执行**

加载到内核缓冲区，必须有一个加载地址。

内核被加载到内存之后，解析elf结构之后必须生成内核映像（复制各种段），这个映像才是真正执行的内核。

搬运指令族：movsb,movsw,movsd

其中movs代表move string，b代表Byte,w代表word,d代表dword

所以分别的含义是：复制1个字节，复制2个字节，复制4字节

![初步加载内核之后的内存布局](/home/xiaoyao/desktop/TinyOS/photos/初步加载内核之后的内存布局.png)

#### 特权级部分



CPL（Current Privilege Level）,即当前特权级

DPL，即 Descriptor Privilege Level，描述符特权级，也是未来的CPL。

RPL，即**请求特权级,他代表了真正请求者的特权级**。

当前特权级是对处理器而言的,并不是对代码段而言的。

门描述符

**它们与段描述符最大的不同是除了任务门外，其他三种门都是对应
到一段例程，即对应一段函数。**

![四种门描述符结构](/home/xiaoyao/图片/截图/四种门描述符结构.png)

调用门的执行流程：

![调用门的执行流程](/home/xiaoyao/图片/截图/调用门的执行流程.png)

调用门就是一个描述符。

call 调用门选择子，该选择子指向了某个门描述符，处理器通过选择子中的索引找到门描述符的地址。门描述符中记录的是内核例程（一段函数）所在代码段的选择子以及偏移量，处理器再使用代码段选择子重复之前的流程，找到内核代码段描述符之后，在代码段描述符中找到内核代码段基址，再加上门描述符中记录的内核例程在代码段中的偏移量，最终得到内核例程的起始地址。

找到内核例程的相关起始地址之后，我们就从用户的3级特权变为内核的0级特权，我们如果要传入参数应该怎么做呢？

处理器在固件上实现了参数的自动复制，也就是说**用户进程压在3特权级栈中的参数会自动复制到0特权级栈中**，所以在门描述符高32位的地方有参数个数。

**当前请求资源者和资源需求方有可能不是一个人，引入RPL的目的就是为了让受访者知道，不管当前的请求者是不是中间人，即使他是代替别人来拿数据的，他也必须要有获取数据权限才可以，否则不允许当前的请求者获取数据。**

举个例子，mov ds，ax 时便会触发特权级检查。ax 中的值**被当作选择子**，处理器会拿 ax 中的低 2 位即 RPL 和 CPL **分别与** ax 中选择子所指向的段描述符的 DPL 做比较，如果满足 RPL≤DPL && CPL≤DPL，**选择子才能被加载到 DS 中**。

jmp指令的对应的前后特权级是平级转移，jmp指令只应用于不需要特权级变化，并且不从调用门返回的结果。

内存段不仅有特权级，指令也有特权级。

![eflags](/home/xiaoyao/图片/截图/eflags.png)

IOPL是IO特权级，他决定了当前任务是否可以操作所有的IO端口。只有任务的当前特权级>=IOPL的时候，才会允许执行全部的IO指令。

如果当前任务的特权级<IOPL的时候，也就是在数值上CPL < IOPL的时候，可以通过IO位图对相应的端口进行访问。

IO位图是位于TSS中的，他可以存在，也可以不存在。

![TSS中的IO位图](/home/xiaoyao/图片/截图/TSS中的IO位图.png)

在TSS中的哪里去找IO位图呢？怎样证明IO位图不存在呢？

有一项是“I/O 位图在 TSS 中的偏移地址”，它在 TSS 中偏移 102 字节的地方，占 2 个字节空间。

TSS 中如果有 I/O 位图的话，它将位于 TSS 的顶端，这就是 TSS 的实际尺寸并不固定的原因，当包括 I/O 位图时，其大小是“I/O 位图偏移地址”+8192+1 字节；若不包括 I/O 位图，其大小则为最小尺寸 104 字节。

既然 I/O 位图位于 TSS 内，那它的地址必须是在 TSS 的尺寸范围之内，即地址的范围是在 TSS偏移（104 ～TSS 段界限 limit）之间，如果偏移地址不在此范围，即大于等于 TSS 段界限 limit（TSS 尺寸大小-1），则表明没有 I/O 位图。

## 第6章：完善内核

### 1.函数约定简介

采用cdecl标准

- 参数是在栈中传递的

- 调用者将所有的参数从右向左入栈
- 调用者清理参数所占的栈空间
- eax，ecx，edx寄存器是由调用者保存的，其余寄存器是由被调用者保存的
- 函数的返回值存储在eax寄存器

### 2.汇编语言和c语言混合编程

单独的汇编文件代码和单独的C语言文件分别编译成目标文件之后，一起链接成可执行程序



global关键字将符号导出为全局属性，对程序中的所有文件可见，这样其他外部文件中也可以引用被global导出的符号。其实就是供外部使用。

引用外部文件的符号用关键字extern声明。



在c语言中嵌入汇编代码，直接编程生成可执行程序

### 3.实现自己的打印函数

Address Register 和Data Register这两个寄存器到底是干什么的？

前者是作为寄存器数组的索引，后者在寄存器数组中对应的寄存器相当于一个窗口，往此窗口中读写的数据都作用在索引所对应的寄存器上了。

即使是这样的，我还是没有理解这样做的目的！！！！

![CRT系列寄存器](/home/xiaoyao/图片/截图/CRT系列寄存器.png)

光标坐标用16位来表示，低八位表示列号，高八位表示行号。

光标值乘以 2 后便是光标在显存中的相对地址。

光标的坐标是存储在光标寄存器中的，索引为 0Eh 的 Cursor Location High Register 寄存器和索引为 0Fh 的 Cursor Location Low Register 寄存器，分别用来存储光标坐标的低 8 位和高 8 位地址。

![滚屏](/home/xiaoyao/图片/截图/滚屏.png)

### 4.AT&T语法

寄存器前有前缀%

源操作数在左，目的操作数在右

指令的最后一个字母表示操作数的大小，b表示1字节，w表示2字节，l表示4字节

立即数前有前缀$，在此语法中内存地址是第一位，一般情况下操作数是数字就默认是内存地址，除非改成立即数

例如：movl %eax, 1

此语法内存寻址有固定的格式：

segreg(段基址):base_address(offset_address, index, size)

对应的表达式是：segreg = base+offset+index*size

- base是基地址，可以是整数或者变量名，可正可负
- offset和index必须是8个通用寄存器之一,所以必须加%
- size是个长度，只能是1,2,4,8

另外需要注意的是格式中没有的部分必须用，来占位

movl %eax,(,%esi,2)

功能是将 eax 的值写入 esi*2 所指向的内存。

movl %eax,(%ebx,%esi,2)
功能是将 eax 的值写入 ebx+esi*2 所指向的内存。

movl %eax,base_value(,%esi,2)
功能是将 eax 的值写入 base_value+esi*2 所指向的内存。

movl %eax,base_value(%ebx,%esi,2)
功能是将 eax 的值写入 base_value+ebx+esi*2 所指向的内存。

#### 基本内联汇编

基本格式：

asm [volatile] ("assembly code")

各关键字之间可以用空格或制表符分隔，也可以紧凑挨在一起不分隔，各部分意义如下：
1.关键字 asm 用于声明内联汇编表达式，这是内联汇编固定的部分，不可少。

asm 和_ _asm _ _是一样的，是由 gcc 定义的宏：#define _ _  asm _ _ asm。

2.关键字 volatile 是可选项，它告诉 gcc：“不要修改我写的汇编代码，请原样保留”。

3.“assembly code”是咱们所写的汇编代码，它必须位于圆括号中，而且必须用双引号引起来。assembly code 甚至可以为空

规则：

- 指令必须用双引号引起来，无论双引号中是一条指令或多条指令
- 一对双引号不能跨行，如果跨行需要在结尾用反斜杠'\'转义
- 指令之间用分号'；'、换行符'\n'或换行符加制表符'\n''\t'分隔。
- 除最后一个双引号外，其余双引号中的代码最后一定要有分隔符

asm(“movl $9,%eax;””pushl %eax”)  正确
asm(“movl $9,%eax””pushl %eax”)   错误

**在基本内联汇编中，若要引用 C 变量，只能将它定义为全局变量。如果定义为局部变量，链接时会找不到这两个符号。**

```c
char* str="hello,world\n";
int count = 0;
void main(){
asm("pusha; \
    movl $4,%eax; \
    movl $1,%ebx; \
    movl str,%ecx;\
    movl $12,%edx;\
    int $0x80;\
    mov %eax,count;\
    popa\
    ");
}
```



#### 扩展内联汇编







## 中断



## 内存管理系统



## 线程



## 输入输出系统

### 同步机制——锁的实现



## 用户进程



## 进一步完善内核

系统调用使用思路：

1.用中断门实现系统调用的入口，0x80作为调用入口

2.在IDT中安装0x80号中断对应的描述符，在该描述符中注册系统调用对应的中断处理例程

3.建立系统调用子功能表syscall_table,利用eax中的子功能号在该表中索引相应的处理函数

4.用宏实现用户空间系统调用接口_syscall

增加系统调用的步骤：

1.在syscall.h中的结构中添加新的子功能号

2.在syscall.c中增加系统调用的接口

3.在syscall_init.c中定义子功能处理函数并且在syscall_table中注册



每次写一个字符到缓冲区之后，就要更新缓冲区指针的值使其指向下一个可以写入的位置。我们可以使用一个变量来存储这个缓冲区指针，可以对这个变量里面的内容进行修改，这种类似于原地操作修改指针的方式最方便的就是用一个指针变量存储指针。

### 完善堆内存管理





## 第13章：硬盘驱动程序

### 硬盘介绍

![磁盘参数](/home/xiaoyao/desktop/TinyOS/photos/磁盘参数.png)

磁盘从上到下参数分别是：

柱面数，磁头数，每个磁道的扇区数，总共的扇区数，总大小MB

![磁盘示意图](/home/xiaoyao/desktop/TinyOS/photos/磁盘示意图.png)

问题是：什么是通道？为什么通道会连接两块硬盘？

其实就是这么规定的。

![硬盘的两种接口](/home/xiaoyao/desktop/TinyOS/photos/硬盘的两种接口.png)

硬盘有并行接口和串行接口，左边的可以叫IDE线，IDE线上可以挂2块硬盘，一个是主盘，一个是从盘。

一个主板上支持4块这样的IDE硬盘，所以主板上提供2个IDE插槽，这两个接口是以0开始编号的，一个是IDE0，一个是IDE1，按照ATA的说法，这两个插槽也称为通道，分别叫Primary通道和Secondary通道。

如果安装的是SATA硬盘，也兼容了PATA的编程接口，兼容了很多。

**不要把所说的主盘 master、从盘 slave 别和 Primary 通道，Secondary 通道搞混了，通道是channel，不是 disk，每个通道上分别有主盘和从盘。**

### 硬盘控制器端口：

硬盘控制器属于IO接口。让硬盘工作，需要通过读写硬盘控制器的端口（寄存器）。

![硬盘控制器的主要端口](/home/xiaoyao/desktop/TinyOS/photos/硬盘控制器的主要端口.png)



data寄存器是用来管理数据的，在读硬盘时，硬盘准备好的数据后，硬盘控制器将其放在内部的缓冲区中，不断读此寄存器便是读出缓冲区中的全部数据。在写硬盘时，我们要把数据源源不断地输送到此端口，数据便被存入缓冲区里，硬盘控制器发现这个缓冲区中有数据了，便将此处的数据写入相应的扇区中。

读硬盘时，端口 0x171 或 0x1F1 的寄存器名字叫 Error 寄存器，只在读取硬盘失败时有用，里面才会记录失败的信息；写硬盘时，此寄存器有了别的用途，叫 Feature 寄存器。强调一下，error 和 feature 这两个名字指的是同一个寄存器，只是因为不同环境下有不同的用途。（非常节俭的使用方法）

尚未读取的扇区数在 Sector count 寄存器中。8 位寄存器，最大值为 255，若指定为 0，则表示要操作 256 个扇区。

硬盘中的扇区在物理上是用“柱面-磁头-扇区”来定位的（Cylinder Head Sector），简称为 CHS，这种定位方法太过麻烦，所以希望磁盘中的扇区从0开始递增，不用考虑扇区的物理结构。所以就引出了一种逻辑上为扇区定址的方式，逻辑块地址（LBA）。

LBA有两种，一种是LBA28,一种是LBA48,为简单起见这次采用LBA28模式。

LBA48使用48比特位来描述一个扇区的地址，最大寻址范围是2 的 48 次方。

LBA 寄存器，这里有 LBA low、LBA mid、LBA high 三个，它们三个都是 8 位宽度，low和mid有相应的寄存器来存储，**device 寄存器的低 4 位用来存储 LBA 地址的第 24～27 位。**

通常还需要配合两个寄存器进行使用：

![device寄存器](/home/xiaoyao/desktop/TinyOS/photos/device寄存器.png)

第 4 位用来指定通道上的主盘或从盘，0 代表主盘，1 代表从盘。第 6 位用来设置是否启用 LBA 方式，1 代表启用 LBA 模式，0 代表启用 CHS 模式。

**在读硬盘时**，端口 0x1F7 或 0x177 的寄存器名称是 Status，它是 8 位宽度的寄存器，用来给出硬盘的状态信息。

**在写硬盘时**，端口 0x1F7 或 0x177 的寄存器名称是 command，它和 status 寄存器是同一个。

总结下寄存器 error和feature ， status和command，大家可以这样来助记：**这两组都是各自情况下的同一寄存器（也就是同一端口）多个用途，**对同一端口写操作时，硬盘控制器认为这是个命令，对同一端口读操作时，硬盘控制器认为是想获得状态。

![status寄存器](/home/xiaoyao/desktop/TinyOS/photos/status寄存器.png)

常用的硬盘操作方法：

约定个步骤：
（1）先选择通道，往该通道的 sector count 寄存器中写入待操作的扇区数。
（2）往该通道上的三个 LBA 寄存器写入扇区起始地址的低 24 位。
（3）往 device 寄存器中写入 LBA 地址的 24～27 位，并置第 6 位为 1，使其为 LBA 模式，设置第 4位，选择操作的硬盘（master 硬盘或 slave 硬盘）。
（4）往该通道上的 command 寄存器写入操作命令。
（5）读取该通道上的 status 寄存器，判断硬盘工作是否完成。
（6）如果以上步骤是读硬盘，进入下一个步骤。否则，完工。
（7）将硬盘数据读出。

***硬盘通道是硬盘*上的一段逻辑路径，负责将计算机数据传输到磁盘上，是*硬盘*工作的核心部件。**



![分区表项结构](/home/xiaoyao/desktop/TinyOS/photos/分区表项结构.png)



主分区和扩展分区，逻辑分区这三个概念是真的绕。

目前我理解的扩展分区：此时的扩展分区描述符指向的是另一个分区（柱面），在这个柱面（习惯把这个柱面称为主扩展分区）里面我们利用扇区又存储了多个分区表（分别存储分区表的又称为子扩展分区），利用链表将多个分区表连接在一起，扇区中的结构和MBR的512字节很相似，前面的引导程序EBR，加上后面的分区表，只不过此时的分区表是扩展的分区表，我们只是使用了前两个表项，第一个表项用来描述包含的逻辑分区的元信息，第二个表项用来描述下一个扩展分区的地址，第三个和第四个表项暂时还没有使用到。——这个概念和一级索引非常类似。



**挂载就是利用一个目录当做进入点，将磁盘分区的数据放置在该目录下，进入该目录之后就可以读取该分区的信息。进入点的目录称为挂载点。**



驱动程序真的写的时候太麻烦了，写驱动程序之前，不仅要了解硬件的一些特性（端口号，返回值，寄存器之类的）还要知道硬件初始化的时候信息存储格式，需要顺利地写程序读出来，简直太疯狂了！！！！



## 第14章：文件系统

硬盘是低速设备，他的读写单位是扇区。

为了避免频繁的访问硬盘，我们不可能有了一扇区的数据甚至没有一扇区的内容就去读写一次硬盘，这样的开销太大了。所以一般的操作是等数据攒到足够大小的时候才会一次性访问硬盘。

这个足够大小的数据就是块，块是扇区的整数倍，在windows中块被称为簇。

块是文件系统的读写单位，因此文件至少要占据一个块，当文加体积大于一个块的时候，文件肯定要被拆分成多个块进行存储。

**问题是：如何把这多个块组织在一起呢？**

对于FAT文件系统而言：他在每一个块的最后存储下一个块的地址，从而通过这种链式方法将块与块之间串连起来，但是这种方式也有一定的弊端就是如果想要访问文件的某一个块的话，必须从头开始遍历这个文件对应的所有块节点。

![FAT文件系统](/home/xiaoyao/desktop/TinyOS/photos/FAT文件系统.png)

FAT文件系统是最初微软公司对应的文件系统，我们来看一下unix中的文件系统——他将文件按照**索引结构来组织**。

### 基于inode的文件系统

inode就是用来**记录磁盘块的一种结构**，他记录了**一个文件对应的所有存储块号**——换一种说法就是**存储的索引**。

每一个文件都必须有一个inode结构，磁盘有多少inode也就有多少文件。

**通过一个inode，我们就可以访问这个文件所有的数据**。inode结构的设计如图：

![inode节点](/home/xiaoyao/desktop/TinyOS/photos/inode节点.png)

在inode结构中，从上到下依次是**基本元信息**，**12个直接块指针**，**一个一级间接块索引指针**，**一个二级指针**，**一个三级指针**。

一个指针对应的就是一个块的大小，因此我们可以通过这样的方式计算出来一个inode所能管理的最大文件大小为48k+6M+1G。

**从上面可以支持的文件数据大小可以看出，一个文件系统所支持的最大文件大小受文件数据组织方式的限制。如果我们想增大文件的大小，完全可以多放几个二级指针或者一级指针。**

**一个文件系统通常还会支持多种文件类型：常规文件，目录文件，符号连接文件，套接字文件等等。**

inode是文件在整个文件系统中的元信息，要想通过文件系统获得文件的数据，必须要先找到文件的inode。

**如何找到inode就是我们访问文件内容的关键！！！**

**为了方便管理，我们将分区中所有的inode通过表格进行维护，称为inode_table，inode_table的下标就是inode的编号。**

文件的数量间接上决定了分区空间的利用率，什么是inode利用率，什么是空间利用率？

操作系统引导记录OBR具体的概念不是很清楚。

### 文件名与目录项

文件是与inode一一对应的，通过inode编号就可以找到对应的文件，但是用户不可能记忆inode编号吧，这样也显得太不人性化了，我们肯定项通过文件名找到对应的inode，为了满足这一需求，**文件系统增加了文件名到inode号之间的映射。**

又有一个问题，inode字段中并不包含文件名，文件名并不是文件的基本元信息，那么我们把文件名放在哪里呢？？？

**通过目录！！！**

目录是特殊的文件，记录了从文件名到inode号之间的映射。

找到了存放的地址，既然都是通过inode来表示文件和目录的，那么我们在哪里可以区分出来是普通文件还是目录呢？**唯一的地方就只能是数据块本身的内容了**——如果是普通文件，那么inode指向的数据块就是文件的具体数据；如果是目录文件，指向的数据块应该是目录下的目录项。

![目录项](/home/xiaoyao/desktop/TinyOS/photos/目录项.png)

可以看到其中的信息：inode号用于找到文件名对应的inode结构，从而访问文件的数据和元数据；**目录项长度用于记录整个目录项的长度，主要是为了删除和重用进行设计。**文件名长度顾名思义。**（另外，我们可以通过目录项长度和文件名长度实现文件名的变长，不用提前规定好文件名的长度）**

一个目录项就是一个entry，目录就相当于一个文件列表，各个entry中的内容就包含在以上部分。

### 超级块与文件系统的存储布局

#### 超级块

我们都知道每个文件都有一个inode,所有inode都在inode_table中，但是inode_table的地址在哪？另外，虽然说每一个分区都有自己的根目录，但是每一个分区的根目录地址都不统一，我们需要一个地方来记录这些信息。

超级块中存储的就是文件系统元信息的配置。

**各个分区中inode数组的长度是固定的，等于最大文件数量**。文件系统是针对于各个分区进行管理的，虽然说各个分区可创建的最大文件数量是固定的，但是我们可以给每一个分区设置不同的文件数。（好好理解这句话）

既然inode数量是有限的，我们要有一个管理inode使用情况的数据结构——inode位图。

空闲块也是有限的，因此也需要一个管理空闲快的使用情况——空闲块位图。

**这两个位图的地址以及大小都在超级块中存储。**但是位图中真正的数据不在这里面。

![超级块逻辑结构](/home/xiaoyao/desktop/TinyOS/photos/超级块逻辑结构.png)

魔数是用来区分文件系统类型的。

超级块的位置被固定在各个分区的第2个扇区，大小通常是占一个扇区大小。

#### 存储布局

文件系统将存储空间划分成不同的区域分别用于不同的功能。

![文件系统布局](/home/xiaoyao/desktop/TinyOS/photos/文件系统布局.png)

**操作系统引导块就是曾经介绍过的操作系统引导记录 OBR 所在的地址，即操作系统引导扇区，它位于各分区最开始的扇区，根据文件系统类型的不同，引导程序可能占用多个扇区，这多个扇区组成一个数据块，因此这里标出的是引导“块”，而不是引导“扇区”。**

现在不是很理解这个引导块的作用！！！！下去需要好好看看。

![存储布局](/home/xiaoyao/desktop/TinyOS/photos/存储布局.png)

inode表对应的就是具体的inode，块分配信息和inode分配信息使用的是位图来记录各种信息。

从上述可以看出，在一个存储设备上创建一个新的文件系统之后，文件系统显示的可用大小往往比存储设备要小，因为会有一些元信息，真正只有文件数据区才存放应用程序的数据。

### 其他知识

#### 硬链接和符号链接



#### 虚拟文件系统

几个问题：

多个文件系统如何共同工作在一个操作系统上？操作系统可以识别吗？是如何识别的？

为什么可以使用一个统一的接口（比如open,read）来访问多个不同文件系统上的文件？   我记得好像是函数指针实现了这种。

伪文件系统是什么？为什么要有伪文件系统？



##### 面向文件系统的接口



##### 面向应用程序的接口



思考：**我觉得虚拟文件系统很妙，他保证了不同的文件系统都可以指通过一个接口就可以访问。有点c++中多态的意思，多态也是通过函数指针的方式来实现的。以后在设计的时候，不同的模块有相似的地方，但是想通过一个统一的接口进行访问的，可以向上抽象一层，通过函数指针或者是其他方式来实现这种功能！！！**



#### 文件描述符

inode是OS为文件系统准备的数据结构，也就是说是在内核中维护的，与用户关系不大，但是为了保证在用户层面也有一层相对应的，所以有了文件描述符。**文件描述符与用户是息息相关的。**

所有的操作系统都支持一个进程同时，多次打开同一个文件，同时也支持多个文件被多个不同的进程同时打开。

但是就有一个问题，多个进程打开多个文件，必然会对文件进行相应的操作，每一个操作都是不同的，每一个操作对应的文件偏移量都是不同的，**为了实现这种隔离性，使得各个操作都互不影响，应该怎样做呢？**

**在这里文件系统又抽象了一层：file结构（也叫文件结构）。**

**思考：在对文件资源已经进行inode抽象之后，如果我们想要对资源进行相关操作，就必须对inode进行操作，因此我们又可以抽象一层动作，专门对资源进行相关的操作和管理。这种思想非常值得借鉴！！！——对资源有了表示，对资源进行操作的也就是对表示进行操作，可以进一步抽象一层动作。至于动作过程中的线程安全问题可以再考虑一下：在内核层面提供这种安全？还是用户自己操作的时候需要提供这种安全？**

文件系统的具体实现过程可以加深这种理解！！！

在他里面专门用于记录与文件操作的相关信息，每次打开一个文件都会产生一个文件结构，多次打开同一个文件就会生成多个文件结构，各自文件操作的偏移量记录在各自的文件结构中。

![fd与inode关系](/home/xiaoyao/desktop/TinyOS/photos/fd与inode关系.png)

文件结构这个数据结构专门用来**记录与文件操作**的相关信息，每次打开一个文件都会产生一个文件结构；把多个文件结构统一组织一起管理形成一个数组——文件表，我们在进行文件相关的操作的时候只要知道文件结构的下标就可以从文件表中找到对应的文件结构；PCB中的文件描述符数组提供这个下标，**准确的说文件描述符是PCB中文件描述符数组元素的下标，而这个下标对应的元素信息又指向了文件表中的某一个文件结构。**

#### Q：文件描述符和文件句柄之间的关系是什么？！

尽管上述图中相关结构比较简陋，但是还是从上面的可以看出来，文件表中的一项其实就称为一条文件描述，也称为文件句柄。文件句柄中存储的是对文件的相关操作，一个fd对应一个文件句柄，但是多个文件句柄可能同时对应多个inode。

**fd是进程级别的，而文件句柄/文件表是系统级别的，他们两者不同，分别在不同的层面表示已经打开的文件。**

**fd与文件句柄直接关联，文件句柄与inode直接关联。**



创建文件描述符的过程：

（1）在全局的 inode 队列中新建一 inode（这肯定是在空位置处新建），然后返回该 inode 地址。
（2）在全局的文件表中的找一空位，在该位置填充文件结构，使其 fd_inode 指向上一步中返回的 inode地址，然后返回本文件结构在文件表中的下标值。
（3）在 PCB 中的文件描述符数组中找一空位，使该位置的值指向上一步中返回的文件结构下标，并返回本文件描述符在文件描述符数组中的下标值。



为直接索引，一级索引，二级索引分配块地址是一个不好做的工作！！！

问一下他们这里的逻辑问题，看不懂这里！！！



## 系统交互

### fork的原理以及实现

实现fork分为两步：

- 给子进程复制父进程资源
- 跳到子进程执行

需要复制的资源：

1.进程的PCB

2.程序体，也就是代码段和数据段等，这些是进程运行的实体

3.用户栈，编译器会将局部变量在栈中创建，函数调用同样也离不开栈

4.内核栈，进入内核态的时候用他来保存上下文环境

5.虚拟内存池，每个进程都拥有独立的内存空间，他们的虚拟地址都是用虚拟内存池来管理的

6.页表，让进程拥有独立的内存空间

如何执行：将PCB中的tag加入到就绪队列中就好了



### 实现wait和exit系统调用

exit是由子进程调用的，他使得子进程结束运行并且传递返回值给内核，本质上是内核会将此子进程中除PCB以外的所有资源都回收。

wait是由父进程调用的，他使得父进程阻塞自己，直到子进程调用exit结束之后获得子进程的返回值，本质上是内核将子进程的返回值传递给父进程并唤醒父进程，然后将子进程的PCB回收。

**孤儿进程：父进程提前退出，他所有的子进程还在运行，没有一个执行exit，所有子进程的声明周期还没有结束，个个都拥有全尸，所以称为孤儿进程。**

这个时候这些子进程会被init进程收养，当子进程退出的时候init会进行相关操作。

**僵尸进程：父进程产生子进程之后没有调用exit退出也没有调用wait等待接收子进程的返回值，这个时候子进程exit退出了没有父进程为其善后，没有父进程接收子进程的返回值，而且此时其子进程占的PCB不能释放，也就成了僵尸进程。**

僵尸进程没有进程体，进程体在exit的时候都已经被内核回收了，只剩下一个PCB还在进程队列中。



### 管道

管道是进程间通信的方式之一，管道也是被看作是文件，但是该文件并不存在于文件系统中而是只存在于内存中。其实管道实质上就是内核空间中的内存缓冲区。

管道有两端，一端用于从管道中读入数据，另一端用于往管道中写入数据。

**但是比较神奇的是这两端都是使用文件描述符相关的方式来进行读取！**

**创建管道实质上就是在内核中为其返回了用于读取管道缓冲区的文件描述符，一个描述符用于读，另一个描述符用于写。**

![管道](/home/xiaoyao/desktop/TinyOS/photos/管道.png)

想要实现父子进程之间的通信，必须创建管道之后fork，这样才可以为其提供保证。

![父子进程管道通信](/home/xiaoyao/desktop/TinyOS/photos/父子进程管道通信.png)



先来看一看linux文件结构中与vfs实现的管道

![linux管道](/home/xiaoyao/desktop/TinyOS/photos/linux管道.png)

文件系统中file结构中的名称已经固定了，再改变的话成本太高（还要去修改各种函数中的内容），现在也不想增加额外的成员，**因此只能把成员的作用改变！！！！**

具体的改变我们来看：

inode是用来识别一个普通文件或者是目录的，管道是新的文件类型但是不需要inode，如何在文件结构中识别而不是误把它当作一般的inode来处理呢？

为管道增加一个文件标志，将fd_flags的值增加一个0xffff，此时的fd_inode指向的是管道的内存缓冲区，fd_pos用于表示此管道的打开数。
