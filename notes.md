$表示的是在文件中的真实地址

$$表示的是在段在文件中的真实地址

vstart给一个虚拟地址



**直接，间接，绝对，相对，远，近这6组概念区分**

实模式下的call

直接：目标函数的地址（操作数）直接给出，是个立即数。

间接：目标函数的地址没有直接给出，地址要么在寄存器中要么在内存中。

绝对：目标函数的地址是绝对地址，是段内偏移值。

相对：目标函数的地址是相对地址，相对当前指令的偏移值。（我理解的还有一层是相对于当前指令下一条指令的偏移值）

远：段间，目标函数和当前代码段不是一个段。

近：段内，目标函数和当前代码段是一个代码段。

前两种是近调用，后两种是远调用

- 16位实模式相对近调用
- 16位实模式间接绝对近调用
- 16位实模式直接绝对远调用
- 16位实模式间接绝对远调用

实模式下的jmp

- 16位实模式相对短转移
- 16位实模式相对近转移
- 16位实模式间接绝对近转移
- 16位实模式直接绝对远转移





约定个步骤：
（1）先选择通道，往该通道的 sector count 寄存器中写入待操作的扇区数。
（2）往该通道上的三个 LBA 寄存器写入扇区起始地址的低 24 位。
（3）往 device 寄存器中写入 LBA 地址的 24～27 位，并置第 6 位为 1，使其为 LBA 模式，设置第 4 位，选择操作的硬盘（master 硬盘或 slave 硬盘）。
（4）往该通道上的 command 寄存器写入操作命令。
（5）读取该通道上的 status 寄存器，判断硬盘工作是否完成。
（6）如果以上步骤是读硬盘，进入下一个步骤。否则，完工。
（7）将硬盘数据读出。



保护模式：

1.寻址扩展

2.运行模式扩展

3.指令扩展

## 保护模式入门

![段描述符格式](/home/xiaoyao/desktop/TinyOS/photos/段描述符格式.png)

段描述符是8B大小。

1.保护模式下地址总线宽度是 32 位，**段基址需要用 32 位地址来表示。**

2.段界限表示段边界的**扩展最值**，即最大扩展到多少或最小扩展到多少。扩展方向只有上下两种。如果 **G 位为 0**，表示段界限粒度大小为 1 字节；如果 **G 位为 1**，表示段界限粒度大小为 4KB字节。

3.CPU眼中，凡是**硬件运行**需要用到的东西都称之为系统段，凡是**软件需要**的东西都称之为数据段。无论是代码还是数据，他们都是软件运行的必须品，只不过借助硬件在硬件上运行，并不属于硬件运行的必须品，所以他们都称为数据。S为1表示数据段，S为0表示系统段。

4.type 字段，该字段共 4 位，用于表示内存段或门的子类型。**type 字段是要和 S 字段配合在一起才能确定段描述符的确切类型，只有 S 字段的值确定后，type 字段的值才有具体意义。**

![段描述符的type类型](/home/xiaoyao/desktop/TinyOS/photos/段描述符的type类型.png)

5.段描述符的第 13～14 位是 DPL 字段，即描述符特权级。两位能表示 4 种特权级，分别是 0、1、2、3 级特权，数字越小，特权级越大

6.段描述符的第 15 位是 P 字段，Present，即段是否存在。如果段存在于内存中，P 为 1，否则 P 为 0。

7.段描述符的第 20 位为 AVL 字段，从名字上看它是 AVaiLable，可用的。

8.段描述符的第 21 位为 L 字段，用来设置是否是 64 位代码段。L 为 1 表示 64 位代码段，否则表示 32位代码段。

9.段描述符的第 22 位是 D/B 字段，用来指示有效地址（段内偏移地址）及操作数的大小。指定“操作数”的大小，也就是对“指令”来说
的，与指令相关的内存段是代码段和栈段，所以此字段是 D 或 B。

- 对代码段来说，是D，若D=0,表示有效地址和操作数都是16位，指令有效地址用IP寄存器。若D=1,32位，有效地址用EIP寄存器。
- 对栈段来说，是B，若B=0,使用sp寄存器，栈的起始地址是16位寄存器的最大寻址范围，0xFFFF;若B=1,使用esp寄存器，栈的起始地址是32位寄存器，0xFFFFFFFF。

这些描述符全部放在GDT全局描述符表中。

GDT位于内存中，需要专门的寄存器指向他。 GDTR，即 GDT Register，专门用来存储 GDT 的内存地址及大小。GDTR 是个 48 位的寄存器。

![GDTR](/home/xiaoyao/desktop/TinyOS/photos/GDTR.png)

现在段寄存器中存的是叫选择子的东西，选择子**基本上**是一个索引值，用此索引值去GDT中寻找相应的段描述符。

![](/home/xiaoyao/desktop/TinyOS/photos/段选择子.png)

控制寄存器是 CPU 的窗口，既可以用来展示 CPU的内部状态，也可用于控制 CPU 的运行机制。

进入保护模式之前，需要将打开开关，PE位置1,启动保护模式。

![](/home/xiaoyao/图片/截图/CR0寄存器.png)

## 向内核迈进

### 1.获取物理内存容量

启用BIOS中断0x15功能

- 子功能0xe820

由于系统内部内存各部分的类型属性不同，此功能就是按照类型属性来划分这片系统内存，每次BIOS只返回一种类型的内存信息。

使用**地址范围描述符（ARDS）**来描述各种内存类型信息。

地址范围描述符的结构（共20个字节，160位）：

![ARDS](/home/xiaoyao/图片/截图/ARDS.png)

每一次int 0x15之后，BIOS就会返回这么一个结构。

调用前输入：

eax：子功能号

ebx：ARDS的后续值,第一次调用一定要置为0,每次中断返回值后BIOS都会更新此值。

es : di：ARDS缓冲区

ecx：ARDS结构的字节大小

edx：固定签名标记0x534d4150，此十六进制数字是字符串 SMAP 的 ASCII 码：BIOS 将调用者正在请求的内存信息写入 ES：DI 寄存器所指向的 ARDS 缓冲区后，再用此签名校验其中的信息

- 子功能0xe801

最大只能识别4G内存。检测到的内存是分别放在两组寄存器中。

<15M的内存以1k为单位，单位数量在ax和cx中记录，两个值一样，实际内存大小是ax✖1024

16M-4G的内存以64k为单位，数量在bx和dx中记录，两个值一样，实际内存大小是bx✖64✖1024

- 子功能0x88

只能识别最大64M的内存大小。

### 2.启动分页机制

分页机制本质上是将大小不等的段拆分成大小相等的页，也可以**理解成小内存块**。

CPU中一页是4K大小。

分页机制打开前要将**页表地址**加载到控制寄存器 cr3 中

![一级页表转成物理地址过程](/home/xiaoyao/图片/截图/一级页表转成物理地址过程.png)

例子：在一级页表的情况下，mov ax，[0x1234]来看，先将地址送入段部件得到一个线性地址，然后将线性地址送入页部件，经过转化得到其对应的物理地址。（熟悉一下顺序）

![二级页表转化过程图](/home/xiaoyao/图片/截图/二级页表转化过程图.png)

关键是**cr3寄存器(页目录基址寄存器)**存储的就是页目录物理地址。

![页目录项以及页表项](/home/xiaoyao/图片/截图/页目录项以及页表项.png)

自己设计页目录表和页表的内存布局

总个1024个页表，每一个页表占4K

 ![布局](/home/xiaoyao/图片/截图/布局.png)

将来内核运行在3G以上的空间，打印功能也应该在内核中实现，用户肯定不可以直接操作显存，所以显存的段基址也要改为3G以上才可以。

我们设计的低端 1MB的虚拟内存空间，其与物理内存 1MB 是一一对应的，在 0～1MB 之间，访问其中任何一个虚拟地址，最终都转换成与其等值的物理地址。

### 3.加载内核

虽然目前第一个内核程序（简单的while循环）非常简洁，和电脑中真正的内核相差非常多，但是目的有两个：

- 演示如何加载内核
- 演示elf格式的文件解析

操作系统加载用户程序的时候无非就是jmp或者call，需要我们显示的指明地址在哪里。

之前的所有地址都是固定的，方法非常不灵活，需要调用方和被调用方提前约定好调用地址。

有没有一种灵活的方法让程序的加载地址不那么固定呢？——有，当然有，每个程序是单独运行的，所以可以在程序的头部设置一段空间，在这个空间中写入程序的入口地址，调用的时候规定从程序的相应空间中将程序的入口地址读出来，**紧接着把程序体整体复制到执行文件的入口地址（这个入口地址应该之前设置的一样）**，然后再加载到执行文件的入口地址执行，jmp过去就可以了。

程序的文件头就记录着这部分信息，记录着描述程序布局等信息——也称为元信息。

还有一个问题就是程序头我们完全可以自己指定，只要保证最后按照我们的格式来解析就可以。

但是这样毕竟不通用，为了通用性最后就采用了gcc生成的elf文件格式。

生成可执行文件的过程：**源程序编译成目标文件，再将目标文件链接成二进制可执行文件。**

目标文件也称为待重定位文件，重定位文件就是指文件里面用到的符号还没有安排地址。所以一律在链接阶段对符号进行重定位。

**链接可以指定最终生成可执行文件的起始虚拟地址。**

链接器规定，默认只把名为_start 的函数作为程序的入口地址，即默认的 entry symbol 是_start，除非另行指定。

#### elf——Executable and Linkable Format，可执行链接格式（文件格式）

程序中最重要的就是段和节了，他们是真正的程序体。多个节经过链接之后就被合并为一个段了。

段和节的信息也是用header来表示的。因为程序中段和节的数量以及大小不固定，专门找了个数据结构存储他们，就是程序头表（program header table）和节头表(section header table)。两个既然都是表，这说明表里面存储的是多个程序头 program header 和多个节头 section header 的信息。

程序头表其实就是用来描述段的，也可以称作段头表。

用一个固定大小的数据结构来描述程序中程序头表和节头表的大小以及位置信息，我们称为ELF header——位于文件最开始的地方，并且具有固定大小。

<img src="/home/xiaoyao/图片/截图/elf header.png" alt="elf header" style="zoom:150%;" />

程序头表中的每个条目是用来描述各个段的信息的，来看每个条目的数据结构。

程序头表中描述的段是位于磁盘上的程序中的一个段，也就是磁盘上的程序文件中的内容格式，并不是之前的内存中的段。

![program header](/home/xiaoyao/图片/截图/program header.png)

![ELF文件格式布局](/home/xiaoyao/图片/截图/ELF文件格式布局.png)

简单的第一个内核文件main.c编译成elf目标文件之后，查看部分相关信息。

具体的在文件中二进制表现形式如图：

![每一个字节的表现形式](/home/xiaoyao/图片/截图/每一个字节的表现形式.png)

左边的是在文件中的偏移量，**中间的是文件中的内容**，按照16进制输出，两个16进制是一个字节，一行共有16个字节。

7F，45,4c,46分别是e_ident[0]，e_ident[1],e_ident[2],e_ident[2]的内容，其他的会依次类推。

**思考：我们在程序中的结构体等变量最终都是通过编码来在文件中存储的，只要我们找准文件偏移量就可以将文件中的这些数据读取出来，然后再进行相应的处理。**

我们还可以通过readelf命令来具体查看相关信息：

![readelf命令](/home/xiaoyao/图片/截图/readelf命令.png)

-e 参数相当于'-h' + '-l' + '-S'，能让大家看到 elf header(file header)、program header 和 section header。

可以通过这个命令来简单的看看elf文件中的相关信息。

#### 将内核载入内存

- 加载内核：把内核文件加载到内核缓冲区，意思是把内核从硬盘上拷贝到内存中，并不是运行内核代码。
- 初始化内核：**在分页之后，将加载进来的elf内核文件安置到相应的虚拟内存，然后跳过去执行**

加载到内核缓冲区，必须有一个加载地址。

内核被加载到内存之后，解析elf结构之后必须生成内核映像（复制各种段），这个映像才是真正执行的内核。

搬运指令族：movsb,movsw,movsd

其中movs代表move string，b代表Byte,w代表word,d代表dword

所以分别的含义是：复制1个字节，复制2个字节，复制4字节

![初步加载内核之后的内存布局](/home/xiaoyao/图片/截图/初步加载内核之后的内存布局.png)

#### 特权级部分



CPL（Current Privilege Level）,即当前特权级

DPL，即 Descriptor Privilege Level，描述符特权级，也是未来的CPL。

RPL，即**请求特权级,他代表了真正请求者的特权级**。

当前特权级是对处理器而言的,并不是对代码段而言的。

门描述符

**它们与段描述符最大的不同是除了任务门外，其他三种门都是对应
到一段例程，即对应一段函数。**

![四种门描述符结构](/home/xiaoyao/图片/截图/四种门描述符结构.png)

调用门的执行流程：

![调用门的执行流程](/home/xiaoyao/图片/截图/调用门的执行流程.png)

调用门就是一个描述符。

call 调用门选择子，该选择子指向了某个门描述符，处理器通过选择子中的索引找到门描述符的地址。门描述符中记录的是内核例程（一段函数）所在代码段的选择子以及偏移量，处理器再使用代码段选择子重复之前的流程，找到内核代码段描述符之后，在代码段描述符中找到内核代码段基址，再加上门描述符中记录的内核例程在代码段中的偏移量，最终得到内核例程的起始地址。

找到内核例程的相关起始地址之后，我们就从用户的3级特权变为内核的0级特权，我们如果要传入参数应该怎么做呢？

处理器在固件上实现了参数的自动复制，也就是说**用户进程压在3特权级栈中的参数会自动复制到0特权级栈中**，所以在门描述符高32位的地方有参数个数。

**当前请求资源者和资源需求方有可能不是一个人，引入RPL的目的就是为了让受访者知道，不管当前的请求者是不是中间人，即使他是代替别人来拿数据的，他也必须要有获取数据权限才可以，否则不允许当前的请求者获取数据。**

举个例子，mov ds，ax 时便会触发特权级检查。ax 中的值**被当作选择子**，处理器会拿 ax 中的低 2 位即 RPL 和 CPL **分别与** ax 中选择子所指向的段描述符的 DPL 做比较，如果满足 RPL≤DPL && CPL≤DPL，**选择子才能被加载到 DS 中**。

jmp指令的对应的前后特权级是平级转移，jmp指令只应用于不需要特权级变化，并且不从调用门返回的结果。

内存段不仅有特权级，指令也有特权级。

![eflags](/home/xiaoyao/图片/截图/eflags.png)

IOPL是IO特权级，他决定了当前任务是否可以操作所有的IO端口。只有任务的当前特权级>=IOPL的时候，才会允许执行全部的IO指令。

如果当前任务的特权级<IOPL的时候，也就是在数值上CPL < IOPL的时候，可以通过IO位图对相应的端口进行访问。

IO位图是位于TSS中的，他可以存在，也可以不存在。

![TSS中的IO位图](/home/xiaoyao/图片/截图/TSS中的IO位图.png)

在TSS中的哪里去找IO位图呢？怎样证明IO位图不存在呢？

有一项是“I/O 位图在 TSS 中的偏移地址”，它在 TSS 中偏移 102 字节的地方，占 2 个字节空间。

TSS 中如果有 I/O 位图的话，它将位于 TSS 的顶端，这就是 TSS 的实际尺寸并不固定的原因，当包括 I/O 位图时，其大小是“I/O 位图偏移地址”+8192+1 字节；若不包括 I/O 位图，其大小则为最小尺寸 104 字节。

既然 I/O 位图位于 TSS 内，那它的地址必须是在 TSS 的尺寸范围之内，即地址的范围是在 TSS偏移（104 ～TSS 段界限 limit）之间，如果偏移地址不在此范围，即大于等于 TSS 段界限 limit（TSS 尺寸大小-1），则表明没有 I/O 位图。

## 完善内核

### 1.函数约定简介

采用cdecl标准

- 参数是在栈中传递的

- 调用者将所有的参数从右向左入栈
- 调用者清理参数所占的栈空间
- eax，ecx，edx寄存器是由调用者保存的，其余寄存器是由被调用者保存的
- 函数的返回值存储在eax寄存器

### 2.汇编语言和c语言混合编程

单独的汇编文件代码和单独的C语言文件分别编译成目标文件之后，一起链接成可执行程序



global关键字将符号导出为全局属性，对程序中的所有文件可见，这样其他外部文件中也可以引用被global导出的符号。其实就是供外部使用。

引用外部文件的符号用关键字extern声明。



在c语言中嵌入汇编代码，直接编程生成可执行程序

### 3.实现自己的打印函数

Address Register 和Data Register这两个寄存器到底是干什么的？

前者是作为寄存器数组的索引，后者在寄存器数组中对应的寄存器相当于一个窗口，往此窗口中读写的数据都作用在索引所对应的寄存器上了。

即使是这样的，我还是没有理解这样做的目的！！！！

![CRT系列寄存器](/home/xiaoyao/图片/截图/CRT系列寄存器.png)

光标坐标用16位来表示，低八位表示列号，高八位表示行号。

光标值乘以 2 后便是光标在显存中的相对地址。

光标的坐标是存储在光标寄存器中的，索引为 0Eh 的 Cursor Location High Register 寄存器和索引为 0Fh 的 Cursor Location Low Register 寄存器，分别用来存储光标坐标的低 8 位和高 8 位地址。

![滚屏](/home/xiaoyao/图片/截图/滚屏.png)

### 4.AT&T语法

寄存器前有前缀%

源操作数在左，目的操作数在右

指令的最后一个字母表示操作数的大小，b表示1字节，w表示2字节，l表示4字节

立即数前有前缀$，在此语法中内存地址是第一位，一般情况下操作数是数字就默认是内存地址，除非改成立即数

例如：movl %eax, 1

此语法内存寻址有固定的格式：

segreg(段基址):base_address(offset_address, index, size)

对应的表达式是：segreg = base+offset+index*size

- base是基地址，可以是整数或者变量名，可正可负
- offset和index必须是8个通用寄存器之一,所以必须加%
- size是个长度，只能是1,2,4,8

另外需要注意的是格式中没有的部分必须用，来占位

movl %eax,(,%esi,2)

功能是将 eax 的值写入 esi*2 所指向的内存。

movl %eax,(%ebx,%esi,2)
功能是将 eax 的值写入 ebx+esi*2 所指向的内存。

movl %eax,base_value(,%esi,2)
功能是将 eax 的值写入 base_value+esi*2 所指向的内存。

movl %eax,base_value(%ebx,%esi,2)
功能是将 eax 的值写入 base_value+ebx+esi*2 所指向的内存。

#### 基本内联汇编

基本格式：

asm [volatile] ("assembly code")

各关键字之间可以用空格或制表符分隔，也可以紧凑挨在一起不分隔，各部分意义如下：
1.关键字 asm 用于声明内联汇编表达式，这是内联汇编固定的部分，不可少。

asm 和_ _asm _ _是一样的，是由 gcc 定义的宏：#define _ _  asm _ _ asm。

2.关键字 volatile 是可选项，它告诉 gcc：“不要修改我写的汇编代码，请原样保留”。

3.“assembly code”是咱们所写的汇编代码，它必须位于圆括号中，而且必须用双引号引起来。assembly code 甚至可以为空

规则：

- 指令必须用双引号引起来，无论双引号中是一条指令或多条指令
- 一对双引号不能跨行，如果跨行需要在结尾用反斜杠'\'转义
- 指令之间用分号'；'、换行符'\n'或换行符加制表符'\n''\t'分隔。
- 除最后一个双引号外，其余双引号中的代码最后一定要有分隔符

asm(“movl $9,%eax;””pushl %eax”)  正确
asm(“movl $9,%eax””pushl %eax”)   错误

**在基本内联汇编中，若要引用 C 变量，只能将它定义为全局变量。如果定义为局部变量，链接时会找不到这两个符号。**

```c
char* str="hello,world\n";
int count = 0;
void main(){
asm("pusha; \
    movl $4,%eax; \
    movl $1,%ebx; \
    movl str,%ecx;\
    movl $12,%edx;\
    int $0x80;\
    mov %eax,count;\
    popa\
    ");
}
```



#### 扩展内联汇编







## 中断



## 内存管理系统



## 线程



## 输入输出系统

### 同步机制——锁的实现



## 用户进程



## 进一步完善内核

系统调用使用思路：

1.用中断门实现系统调用的入口，0x80作为调用入口

2.在IDT中安装0x80号中断对应的描述符，在该描述符中注册系统调用对应的中断处理例程

3.建立系统调用子功能表syscall_table,利用eax中的子功能号在该表中索引相应的处理函数

4.用宏实现用户空间系统调用接口_syscall

增加系统调用的步骤：

1.在syscall.h中的结构中添加新的子功能号

2.在syscall.c中增加系统调用的接口

3.在syscall_init.c中定义子功能处理函数并且在syscall_table中注册



每次写一个字符到缓冲区之后，就要更新缓冲区指针的值使其指向下一个可以写入的位置。我们可以使用一个变量来存储这个缓冲区指针，可以对这个变量里面的内容进行修改，这种类似于原地操作修改指针的方式最方便的就是用一个指针变量存储指针。

### 完善堆内存管理





## 硬盘驱动程序

![磁盘参数](/home/xiaoyao/图片/截图/磁盘参数.png)

磁盘从上到下参数分别是：

柱面数，磁头数，每个磁道的扇区数，总共的扇区数，总大小MB

![磁盘示意图](/home/xiaoyao/图片/截图/磁盘示意图.png)

问题是：什么是通道？为什么通道会连接两块硬盘？

硬盘控制器端口：

让硬盘工作，需要通过读写硬盘控制器的端口（寄存器）。

![硬盘控制器的主要端口](/home/xiaoyao/图片/截图/硬盘控制器的主要端口.png)



data寄存器是用来管理数据的，在读硬盘时，硬盘准备好的数据后，硬盘控制器将其放在内部的缓冲
区中，不断读此寄存器便是读出缓冲区中的全部数据。在写硬盘时，我们要把数据源源不断地输送到此端口，
数据便被存入缓冲区里，硬盘控制器发现这个缓冲区中有数据了，便将此处的数据写入相应的扇区中。

读硬盘时，端口 0x171 或 0x1F1 的寄存器名字叫 Error 寄存器，只在读取硬盘失败时有用，里面才会记录失败的信息；写硬盘时，此寄存器有了别的用途，叫 Feature 寄存器。强调一下，error 和 feature 这两个名字指的是同一个寄存器，只是因为不同环境下有不同的用途。

尚未读取的扇区数在 Sector count 寄存器中。8 位寄存器，最大值为 255，若指定为 0，则表示要操作 256 个扇区。

硬盘中的扇区在物理上是用“柱面-磁头-扇区”来定位的（Cylinder Head Sector），简称为 CHS，这种定位方法太过麻烦，所以希望磁盘中的扇区从0开始递增，不用考虑扇区的物理结构。所以就引出了一种逻辑上为扇区定址的方式，逻辑块地址（LBA）。

LBA有两种，一种是LBA28,一种是LBA48,为简单起见这次采用LBA28模式。

LBA48使用48比特位来描述一个扇区的地址，最大寻址范围是2 的 48 次方。

LBA 寄存器了，这里有 LBA low、LBA mid、LBA high 三个，它们三个都是 8 位宽度，device 寄存器的低 4 位用来存储 LBA 地址
的第 24～27 位。

通常还需要配合两个寄存器进行使用：

![device寄存器](/home/xiaoyao/图片/截图/device寄存器.png)

第 4 位用来指定通道上的主盘或从盘，0 代表主盘，1 代表从盘。第 6 位用来设置是否启用 LBA 方式，1 代表启用 LBA 模式，0 代表启用 CHS 模式。

在读硬盘时，端口 0x1F7 或 0x177 的寄存器名称是 Status，它是 8 位宽度的寄存器，用来给出硬盘的状态信息。

在写硬盘时，端口 0x1F7 或 0x177 的寄存器名称是 command，它和 status 寄存器是同一个。

总结下寄存器 error、feature 和 status、command，大家可以这样来助记：**这两组都是同一寄存器（也就是同一端口）多个用途，**对同一端口写操作时，硬盘控制器认为这是个命令，对同一端口读操作时，硬盘控制器认为是想获得状态。

![status寄存器](/home/xiaoyao/图片/截图/status寄存器.png)

常用的硬盘操作方法：

约定个步骤：
（1）先选择通道，往该通道的 sector count 寄存器中写入待操作的扇区数。
（2）往该通道上的三个 LBA 寄存器写入扇区起始地址的低 24 位。
（3）往 device 寄存器中写入 LBA 地址的 24～27 位，并置第 6 位为 1，使其为 LBA 模式，设置第 4位，选择操作的硬盘（master 硬盘或 slave 硬盘）。
（4）往该通道上的 command 寄存器写入操作命令。
（5）读取该通道上的 status 寄存器，判断硬盘工作是否完成。
（6）如果以上步骤是读硬盘，进入下一个步骤。否则，完工。
（7）将硬盘数据读出。

***硬盘通道是硬盘*上的一段逻辑路径，负责将计算机数据传输到磁盘上，是*硬盘*工作的核心部件。**



![分区表项结构](/home/xiaoyao/图片/截图/分区表项结构.png)



主分区和扩展分区，逻辑分区这三个概念是真的绕。

目前我理解的扩展分区：此时的扩展分区描述符指向的是另一个分区（柱面），在这个柱面（习惯把这个柱面称为主扩展分区）里面我们利用扇区又存储了多个分区表（分别存储分区表的又称为子扩展分区），利用链表将多个分区表连接在一起，扇区中的结构和MBR的512字节很相似，前面的引导程序EBR，加上后面的分区表，只不过此时的分区表是扩展的分区表，我们只是使用了前两个表项，第一个表项用来描述包含的逻辑分区的元信息，第二个表项用来描述下一个扩展分区的地址，第三个和第四个表项暂时还没有使用到。——这个概念和一级索引非常类似。



驱动程序真的写的时候太麻烦了，写驱动程序之前，不仅要了解硬件的一些特性（端口号，返回值，寄存器之类的）还要知道硬件初始化的时候信息存储格式，需要顺利地写程序读出来，简直太疯狂了！！！！



## 文件系统

硬盘是低速设备，他的读写单位是扇区。

为了避免频繁的访问硬盘，我们不可能有了一扇区的数据甚至没有一扇区的内容就去读写一次硬盘，这样的开销太大了。所以一般的操作是等数据攒到足够大小的时候才会一次性访问硬盘。

这个足够大小的数据就是块，块是扇区的整数倍，在windows中块被称为簇。

块是文件系统的读写单位，因此文件至少要占据一个块，当文加体积大于一个块的时候，文件肯定要被拆分成多个块进行存储。

**问题是：如何把这多个块组织在一起呢？**

对于FAT文件系统而言：他在每一个块的最后存储下一个块的地址，从而通过这种链式方法将块与块之间串连起来，但是这种方式也有一定的弊端就是如果想要访问文件的某一个块的话，必须从头开始遍历这个文件对应的所有块节点。

![FAT文件系统](/home/xiaoyao/图片/截图/FAT文件系统.png)

FAT文件系统是微软公司对应的文件系统，我们来看一下unix中的文件系统——他将文件按照**索引结构来组织**。

### 基于inode的文件系统

inode就是用来记录磁盘块的一种结构，他记录了**一个文件对应的所有存储块号**——换一种说法就是**存储的索引**。

每一个文件都必须有一个inode结构，磁盘有多少inode也就有多少文件。

**通过一个inode，我们就可以访问这个文件所有的数据**。inode结构的设计如图：

![inode节点](/home/xiaoyao/图片/截图/inode节点.png)

在inode结构中，从上到下依次是**基本元信息**，**12个直接块指针**，**一个一级间接块索引指针**，**一个二级指针**，**一个三级指针**。

一个指针对应的就是一个块的大小，因此我们可以通过这样的方式计算出来一个inode所能管理的最大文件大小为48k+6M+1G。

**从上面可以支持的文件数据大小可以看出，一个文件系统所支持的最大文件大小受文件数据组织方式的限制。如果我们想增大文件的大小，完全可以多放几个二级指针或者一级指针。**

**一个文件系统通常还会支持多种文件类型：常规文件，目录文件，符号连接文件，套接字文件等等。**

inode是文件在整个文件系统中的元信息，要想通过文件系统获得文件的数据，必须要先找到文件的inode。

如何找到inode就是我们访问文件内容的关键！！！

**为了方便管理，我们将分区中所有的inode通过表格进行维护，称为inode_table，inode_table的下标就是inode的编号。**

文件的数量间接上决定了分区空间的利用率，什么是inode利用率，什么是空间利用率？

操作系统引导记录OBR具体的概念不是很清楚。

### 文件名与目录项

文件是与inode一一对应的，通过inode编号就可以找到对应的文件，但是用户不可能记忆inode编号吧，这样也显得太不人性化了，我们肯定项通过文件名找到对应的inode，为了满足这一需求，**文件系统增加了文件名到inode号之间的映射。**

又有一个问题，inode字段中并不包含文件名，文件名并不是文件的基本元信息，那么我们把文件名放在哪里呢？？？

通过目录！！！

目录是特殊的文件，记录了从文件名到inode号之间的映射。

找到了存放的地址，既然都是通过inode来表示文件和目录的，那么我们在哪里可以区分出来是普通文件还是目录呢？**唯一的地方就只能是数据块本身的内容了**——如果是普通文件，那么inode指向的数据块就是文件的具体数据；如果是目录文件，指向的数据块应该是目录下的目录项。

![目录项](/home/xiaoyao/图片/截图/目录项.png)

可以看到其中的信息：inode号用于找到文件名对应的inode结构，从而访问文件的数据和元数据；**目录项长度用于记录整个目录项的长度，主要是为了删除和重用进行设计。**文件名长度顾名思义。**（另外，我们可以通过目录项长度和文件名长度实现文件名的变长，不用提前规定好文件名的长度）**

一个目录项就是一个entry。

### 超级块与文件系统的存储布局

#### 超级块

我们都知道每个文件都有一个inode,所有inode都在inode_table中，但是inode_table的地址在哪？另外，虽然说每一个分区都有自己的根目录，但是每一个分区的根目录地址都不统一，我们需要一个地方来记录这些信息。

超级块中存储的就是文件系统元信息的配置。

**各个分区中inode数组的长度是固定的，等于最大文件数量**。文件系统是针对于各个分区进行管理的，虽然说各个分区可创建的最大文件数量是固定的，但是我们可以给每一个分区设置不同的文件数。（好好理解这句话）

既然inode数量是有限的，我们要有一个管理inode使用情况的数据结构——inode位图。

空闲块也是有限的，因此也需要一个管理空闲快的使用情况——空闲块位图。

**这两个位图的地址以及大小都在超级块中存储。**但是位图中真正的数据不在这里面。

![超级块逻辑结构](/home/xiaoyao/图片/截图/超级块逻辑结构.png)

魔数是用来区分文件系统类型的。

超级块的位置被固定在各个分区的第2个扇区，大小通常是占一个扇区大小。

#### 存储布局

文件系统将存储空间划分成不同的区域分别用于不同的功能。

![文件系统布局](/home/xiaoyao/图片/截图/文件系统布局.png)

**操作系统引导块就是曾经介绍过的操作系统引导记录 OBR 所在的地址，即操作系统引导扇区，它位于各分区最开始的扇区，根据文件系统类型的不同，引导程序可能占用多个扇区，这多个扇区组成一个数据块，因此这里标出的是引导“块”，而不是引导“扇区”。**

现在不是很理解这个引导块的作用！！！！下去需要好好看看。

![存储布局](/home/xiaoyao/图片/截图/存储布局.png)

inode表对应的就是具体的inode，块分配信息和inode分配信息使用的是位图来记录各种信息。

从上述可以看出，在一个存储设备上创建一个新的文件系统之后，文件系统显示的可用大小往往比存储设备要小，因为会有一些元信息，真正只有文件数据区才存放应用程序的数据。

### 其他知识

#### 硬链接和符号链接



#### 虚拟文件系统

几个问题：

多个文件系统如何共同工作在一个操作系统上？操作系统可以识别吗？是如何识别的？

为什么可以使用一个统一的接口（比如open,read）来访问多个不同文件系统上的文件？   我记得好像是函数指针实现了这种。

伪文件系统是什么？为什么要有伪文件系统？



##### 面向文件系统的接口



##### 面向应用程序的接口



思考：**我觉得虚拟文件系统很妙，他保证了不同的文件系统都可以指通过一个接口就可以访问。有点c++中多态的意思，多态也是通过函数指针的方式来实现的。以后在设计的时候，不同的模块有相似的地方，但是想通过一个统一的接口进行访问的，可以向上抽象一层，通过函数指针或者是其他方式来实现这种功能！！！**



#### 文件描述符

![fd与inode关系](/home/xiaoyao/图片/截图/fd与inode关系.png)

文件结构这个数据结构专门用来记录与文件操作的相关信息，每次打开一个文件都会产生一个文件结构；把多个文件结构统一组织一起管理形成一个数组——文件表，我们在进行文件相关的操作的时候只要知道文件结构的下标就可以从文件表中找到对应的文件结构；PCB中的文件描述符数组提供这个下标，准确的说文件描述符是PCB中文件描述符数组元素的下标，而这个下标对应的元素信息又指向了文件表中的某一个文件结构。

创建文件描述符的过程：

（1）在全局的 inode 队列中新建一 inode（这肯定是在空位置处新建），然后返回该 inode 地址。
（2）在全局的文件表中的找一空位，在该位置填充文件结构，使其 fd_inode 指向上一步中返回的 inode地址，然后返回本文件结构在文件表中的下标值。
（3）在 PCB 中的文件描述符数组中找一空位，使该位置的值指向上一步中返回的文件结构下标，并返回本文件描述符在文件描述符数组中的下标值。



为直接索引，一级索引，二级索引分配块地址是一个不好做的工作！！！

问一下他们这里的逻辑问题，看不懂这里！！！



## 系统交互

### fork的原理以及实现

实现fork分为两步：

- 给子进程复制父进程资源
- 跳到子进程执行

需要复制的资源：

1.进程的PCB

2.程序体，也就是代码段和数据段等，这些是进程运行的实体

3.用户栈，编译器会将局部变量在栈中创建，函数调用同样也离不开栈

4.内核栈，进入内核态的时候用他来保存上下文环境

5.虚拟内存池，每个进程都拥有独立的内存空间，他们的虚拟地址都是用虚拟内存池来管理的

6.页表，让进程拥有独立的内存空间

如何执行：将PCB中的tag加入到就绪队列中就好了



### 实现wait和exit系统调用

exit是由子进程调用的，他使得子进程结束运行并且传递返回值给内核，本质上是内核会将此子进程中除PCB以外的所有资源都回收。

wait是由父进程调用的，他使得父进程阻塞自己，直到子进程调用exit结束之后获得子进程的返回值，本质上是内核将子进程的返回值传递给父进程并唤醒父进程，然后将子进程的PCB回收。

孤儿进程：父进程提前退出，他所有的子进程还在运行，没有一个执行exit，所有子进程的声明周期还没有结束，个个都拥有全尸，所以称为孤儿进程。

这个时候这些子进程会被init进程收养，当子进程退出的时候init会进行相关操作。

僵尸进程：父进程产生子进程之后没有调用exit退出也没有调用wait等待接收子进程的返回值，这个时候子进程exit退出了没有父进程为其善后，没有父进程接收子进程的返回值，而且此时其子进程占的PCB不能释放，也就成了僵尸进程。

僵尸进程没有进程体，进程体在exit的时候都已经被内核回收了，只剩下一个PCB还在进程队列中。



### 管道

管道是进程间通信的方式之一，管道也是被看作是文件，但是该文件并不存在于文件系统中而是只存在于内存中。其实管道实质上就是内核空间中的内存缓冲区。

管道有两端，一端用于从管道中读入数据，另一端用于往管道中写入数据。

**但是比较神奇的是这两端都是使用文件描述符相关的方式来进行读取！**

**创建管道实质上就是在内核中为其返回了用于读取管道缓冲区的文件描述符，一个描述符用于读，另一个描述符用于写。**

![管道](/home/xiaoyao/图片/截图/管道.png)

想要实现父子进程之间的通信，必须创建管道之后fork，这样才可以为其提供保证。

![父子进程管道通信](/home/xiaoyao/图片/截图/父子进程管道通信.png)



先来看一看linux文件结构中与vfs实现的管道

![linux管道](/home/xiaoyao/图片/截图/linux管道.png)

文件系统中file结构中的名称已经固定了，再改变的话成本太高（还要去修改各种函数中的内容），现在也不想增加额外的成员，**因此只能把成员的作用改变！！！！**

具体的改变我们来看：

inode是用来识别一个普通文件或者是目录的，管道是新的文件类型但是不需要inode，如何在文件结构中识别而不是误把它当作一般的inode来处理呢？

为管道增加一个文件标志，将fd_flags的值增加一个0xffff，此时的fd_inode指向的是管道的内存缓冲区，fd_pos用于表示此管道的打开数。
