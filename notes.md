$表示的是在文件中的真实地址

$$表示的是在段在文件中的真实地址

vstart给一个虚拟地址



**直接，间接，绝对，相对，远，近这6组概念区分**

实模式下的call

直接：目标函数的地址（操作数）直接给出，是个立即数。

间接：目标函数的地址没有直接给出，地址要么在寄存器中要么在内存中。

绝对：目标函数的地址是绝对地址，是段内偏移值。

相对：目标函数的地址是相对地址，相对当前指令的偏移值。（我理解的还有一层是相对于当前指令下一条指令的偏移值）

远：段间，目标函数和当前代码段不是一个段。

近：段内，目标函数和当前代码段是一个代码段。

前两种是近调用，后两种是远调用

- 16位实模式相对近调用
- 16位实模式间接绝对近调用
- 16位实模式直接绝对远调用
- 16位实模式间接绝对远调用

实模式下的jmp

- 16位实模式相对短转移
- 16位实模式相对近转移
- 16位实模式间接绝对近转移
- 16位实模式直接绝对远转移





约定个步骤：
（1）先选择通道，往该通道的 sector count 寄存器中写入待操作的扇区数。
（2）往该通道上的三个 LBA 寄存器写入扇区起始地址的低 24 位。
（3）往 device 寄存器中写入 LBA 地址的 24～27 位，并置第 6 位为 1，使其为 LBA 模式，设置第 4 位，选择操作的硬盘（master 硬盘或 slave 硬盘）。
（4）往该通道上的 command 寄存器写入操作命令。
（5）读取该通道上的 status 寄存器，判断硬盘工作是否完成。
（6）如果以上步骤是读硬盘，进入下一个步骤。否则，完工。
（7）将硬盘数据读出。



保护模式：

1.寻址扩展

2.运行模式扩展

3.指令扩展

## 保护模式入门

![段描述符格式](/home/xiaoyao/desktop/TinyOS/photos/段描述符格式.png)

段描述符是8B大小。

1.保护模式下地址总线宽度是 32 位，**段基址需要用 32 位地址来表示。**

2.段界限表示段边界的**扩展最值**，即最大扩展到多少或最小扩展到多少。扩展方向只有上下两种。如果 **G 位为 0**，表示段界限粒度大小为 1 字节；如果 **G 位为 1**，表示段界限粒度大小为 4KB字节。

3.CPU眼中，凡是**硬件运行**需要用到的东西都称之为系统段，凡是**软件需要**的东西都称之为数据段。无论是代码还是数据，他们都是软件运行的必须品，只不过借助硬件在硬件上运行，并不属于硬件运行的必须品，所以他们都称为数据。S为1表示数据段，S为0表示系统段。

4.type 字段，该字段共 4 位，用于表示内存段或门的子类型。**type 字段是要和 S 字段配合在一起才能确定段描述符的确切类型，只有 S 字段的值确定后，type 字段的值才有具体意义。**

![段描述符的type类型](/home/xiaoyao/desktop/TinyOS/photos/段描述符的type类型.png)

5.段描述符的第 13～14 位是 DPL 字段，即描述符特权级。两位能表示 4 种特权级，分别是 0、1、2、3 级特权，数字越小，特权级越大

6.段描述符的第 15 位是 P 字段，Present，即段是否存在。如果段存在于内存中，P 为 1，否则 P 为 0。

7.段描述符的第 20 位为 AVL 字段，从名字上看它是 AVaiLable，可用的。

8.段描述符的第 21 位为 L 字段，用来设置是否是 64 位代码段。L 为 1 表示 64 位代码段，否则表示 32位代码段。

9.段描述符的第 22 位是 D/B 字段，用来指示有效地址（段内偏移地址）及操作数的大小。指定“操作数”的大小，也就是对“指令”来说
的，与指令相关的内存段是代码段和栈段，所以此字段是 D 或 B。

- 对代码段来说，是D，若D=0,表示有效地址和操作数都是16位，指令有效地址用IP寄存器。若D=1,32位，有效地址用EIP寄存器。
- 对栈段来说，是B，若B=0,使用sp寄存器，栈的起始地址是16位寄存器的最大寻址范围，0xFFFF;若B=1,使用esp寄存器，栈的起始地址是32位寄存器，0xFFFFFFFF。

这些描述符全部放在GDT全局描述符表中。

GDT位于内存中，需要专门的寄存器指向他。 GDTR，即 GDT Register，专门用来存储 GDT 的内存地址及大小。GDTR 是个 48 位的寄存器。

![GDTR](/home/xiaoyao/desktop/TinyOS/photos/GDTR.png)

现在段寄存器中存的是叫选择子的东西，选择子**基本上**是一个索引值，用此索引值去GDT中寻找相应的段描述符。

![](/home/xiaoyao/desktop/TinyOS/photos/段选择子.png)

控制寄存器是 CPU 的窗口，既可以用来展示 CPU的内部状态，也可用于控制 CPU 的运行机制。

进入保护模式之前，需要将打开开关，PE位置1,启动保护模式。

![](/home/xiaoyao/图片/截图/CR0寄存器.png)

## 向内核迈进

### 1.获取物理内存容量

启用BIOS中断0x15功能

- 子功能0xe820

由于系统内部内存各部分的类型属性不同，此功能就是按照类型属性来划分这片系统内存，每次BIOS只返回一种类型的内存信息。

使用**地址范围描述符（ARDS）**来描述各种内存类型信息。

地址范围描述符的结构（共20个字节，160位）：

![ARDS](/home/xiaoyao/图片/截图/ARDS.png)

每一次int 0x15之后，BIOS就会返回这么一个结构。

调用前输入：

eax：子功能号

ebx：ARDS的后续值,第一次调用一定要置为0,每次中断返回值后BIOS都会更新此值。

es : di：ARDS缓冲区

ecx：ARDS结构的字节大小

edx：固定签名标记0x534d4150，此十六进制数字是字符串 SMAP 的 ASCII 码：BIOS 将调用者正在请求的内存信息写入 ES：DI 寄存器所指向的 ARDS 缓冲区后，再用此签名校验其中的信息

- 子功能0xe801

最大只能识别4G内存。检测到的内存是分别放在两组寄存器中。

<15M的内存以1k为单位，单位数量在ax和cx中记录，两个值一样，实际内存大小是ax✖1024

16M-4G的内存以64k为单位，数量在bx和dx中记录，两个值一样，实际内存大小是bx✖64✖1024

- 子功能0x88

只能识别最大64M的内存大小。

### 2.启动分页机制

分页机制本质上是将大小不等的段拆分成大小相等的页，也可以**理解成小内存块**。

CPU中一页是4K大小。

分页机制打开前要将**页表地址**加载到控制寄存器 cr3 中

![一级页表转成物理地址过程](/home/xiaoyao/图片/截图/一级页表转成物理地址过程.png)

例子：在一级页表的情况下，mov ax，[0x1234]来看，先将地址送入段部件得到一个线性地址，然后将线性地址送入页部件，经过转化得到其对应的物理地址。（熟悉一下顺序）

![二级页表转化过程图](/home/xiaoyao/图片/截图/二级页表转化过程图.png)

关键是**cr3寄存器(页目录基址寄存器)**存储的就是页目录物理地址。

![页目录项以及页表项](/home/xiaoyao/图片/截图/页目录项以及页表项.png)

自己设计页目录表和页表的内存布局

总个1024个页表，每一个页表占4K

 ![布局](/home/xiaoyao/图片/截图/布局.png)

将来内核运行在3G以上的空间，打印功能也应该在内核中实现，用户肯定不可以直接操作显存，所以显存的段基址也要改为3G以上才可以。

我们设计的低端 1MB的虚拟内存空间，其与物理内存 1MB 是一一对应的，在 0～1MB 之间，访问其中任何一个虚拟地址，最终都转换成与其等值的物理地址。

### 3.加载内核

虽然目前第一个内核程序非常简洁，和电脑中真正的内核相差非常多，但是目的有两个：

- 演示如何加载内核
- 演示elf格式的文件解析

操作系统加载用户程序的时候无非就是jmp或者call，需要我们显示的指明地址在哪里。

之前的所有地址都是固定的，方法非常不灵活，需要调用方和被调用方提前约定好调用地址。

有没有一种灵活的方法让程序的加载地址不那么固定呢？——有，当然有，每个程序是单独运行的，所以可以在程序的头部设置一段空间，在这个空间中写入程序的入口地址，调用的时候规定从程序的相应空间中将程序的入口地址读出来，然后再加载到相应的入口地址，jmp过去就可以了。

程序的文件头就记录着这部分信息，记录着描述程序布局等信息——也称为元信息。

还有一个问题就是程序头我们完全可以自己指定，只要保证最后按照我们的格式来解析就可以。

但是这样毕竟不通用，为了通用性最后就采用了gcc生成的elf文件格式。

#### elf的文件格式

段和节的信息也是用header来表示的。因为程序中段和节的数量以及大小不固定，专门找了个数据结构存储他们，就是程序头表（program header table）和节头表(section header table)。两个既然都是表，这说明表里面存储的是多个程序头 program header 和多个节头 section header 的信息。

程序头表其实就是用来描述段的，也可以称作段头表。

用一个固定大小的数据结构来描述程序中程序头表和节头表的大小以及位置信息，我们称为ELF header——位于文件最开始的地方，并且具有固定大小。

<img src="/home/xiaoyao/图片/截图/elf header.png" alt="elf header" style="zoom:150%;" />

程序头表中的每个条目是用来描述各个段的信息的，来看每个条目的数据结构。

此段描述的是位于磁盘上的程序中的一个段，也就是磁盘上的程序文件中的内容格式，并不是之前的内存中的段。

![program header](/home/xiaoyao/图片/截图/program header.png)

简单的第一个内核文件main.c编译成elf目标文件之后，查看部分相关信息。

具体的在文件中二进制表现形式如图：

![每一个字节的表现形式](/home/xiaoyao/图片/截图/每一个字节的表现形式.png)

左边的是在文件中的偏移量，**中间的是文件中的内容**，按照16进制输出，两个16进制是一个字节，一行共有16个字节。

7F，45,4c,46分别是e_ident[0]，e_ident[1],e_ident[2],e_ident[2]的内容，其他的会依次类推。

**思考：我们在程序中的结构体等变量最终都是通过编码来在文件中存储的，只要我们找准文件偏移量就可以将文件中的这些数据读取出来，然后再进行相应的处理。**

我们还可以通过readelf命令来具体查看相关信息：

![readelf命令](/home/xiaoyao/图片/截图/readelf命令.png)

-e 参数相当于'-h' + '-l' + '-S'，能让大家看到 elf header(file header)、program header 和 section header。

可以通过这个命令来简单的看看elf文件中的相关信息。

#### 将内核载入内存

