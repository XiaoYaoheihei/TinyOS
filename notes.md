$表示的是在文件中的真实地址

$$表示的是在段在文件中的真实地址

vstart给一个虚拟地址



**直接，间接，绝对，相对，远，近这6组概念区分**

实模式下的call

直接：目标函数的地址（操作数）直接给出，是个立即数。

间接：目标函数的地址没有直接给出，地址要么在寄存器中要么在内存中。

绝对：目标函数的地址是绝对地址，是段内偏移值。

相对：目标函数的地址是相对地址，相对当前指令的偏移值。（我理解的还有一层是相对于当前指令下一条指令的偏移值）

远：段间，目标函数和当前代码段不是一个段。

近：段内，目标函数和当前代码段是一个代码段。

前两种是近调用，后两种是远调用

- 16位实模式相对近调用
- 16位实模式间接绝对近调用
- 16位实模式直接绝对远调用
- 16位实模式间接绝对远调用

实模式下的jmp

- 16位实模式相对短转移
- 16位实模式相对近转移
- 16位实模式间接绝对近转移
- 16位实模式直接绝对远转移





约定个步骤：
（1）先选择通道，往该通道的 sector count 寄存器中写入待操作的扇区数。
（2）往该通道上的三个 LBA 寄存器写入扇区起始地址的低 24 位。
（3）往 device 寄存器中写入 LBA 地址的 24～27 位，并置第 6 位为 1，使其为 LBA 模式，设置第 4 位，选择操作的硬盘（master 硬盘或 slave 硬盘）。
（4）往该通道上的 command 寄存器写入操作命令。
（5）读取该通道上的 status 寄存器，判断硬盘工作是否完成。
（6）如果以上步骤是读硬盘，进入下一个步骤。否则，完工。
（7）将硬盘数据读出。



保护模式：

1.寻址扩展

2.运行模式扩展

3.指令扩展

## 保护模式入门

![段描述符格式](/home/xiaoyao/desktop/TinyOS/photos/段描述符格式.png)

段描述符是8B大小。

1.保护模式下地址总线宽度是 32 位，**段基址需要用 32 位地址来表示。**

2.段界限表示段边界的**扩展最值**，即最大扩展到多少或最小扩展到多少。扩展方向只有上下两种。如果 **G 位为 0**，表示段界限粒度大小为 1 字节；如果 **G 位为 1**，表示段界限粒度大小为 4KB字节。

3.CPU眼中，凡是**硬件运行**需要用到的东西都称之为系统段，凡是**软件需要**的东西都称之为数据段。无论是代码还是数据，他们都是软件运行的必须品，只不过借助硬件在硬件上运行，并不属于硬件运行的必须品，所以他们都称为数据。S为1表示数据段，S为0表示系统段。

4.type 字段，该字段共 4 位，用于表示内存段或门的子类型。**type 字段是要和 S 字段配合在一起才能确定段描述符的确切类型，只有 S 字段的值确定后，type 字段的值才有具体意义。**

![段描述符的type类型](/home/xiaoyao/desktop/TinyOS/photos/段描述符的type类型.png)

5.段描述符的第 13～14 位是 DPL 字段，即描述符特权级。两位能表示 4 种特权级，分别是 0、1、2、3 级特权，数字越小，特权级越大

6.段描述符的第 15 位是 P 字段，Present，即段是否存在。如果段存在于内存中，P 为 1，否则 P 为 0。

7.段描述符的第 20 位为 AVL 字段，从名字上看它是 AVaiLable，可用的。

8.段描述符的第 21 位为 L 字段，用来设置是否是 64 位代码段。L 为 1 表示 64 位代码段，否则表示 32位代码段。

9.段描述符的第 22 位是 D/B 字段，用来指示有效地址（段内偏移地址）及操作数的大小。指定“操作数”的大小，也就是对“指令”来说
的，与指令相关的内存段是代码段和栈段，所以此字段是 D 或 B。

- 对代码段来说，是D，若D=0,表示有效地址和操作数都是16位，指令有效地址用IP寄存器。若D=1,32位，有效地址用EIP寄存器。
- 对栈段来说，是B，若B=0,使用sp寄存器，栈的起始地址是16位寄存器的最大寻址范围，0xFFFF;若B=1,使用esp寄存器，栈的起始地址是32位寄存器，0xFFFFFFFF。

这些描述符全部放在GDT全局描述符表中。

GDT位于内存中，需要专门的寄存器指向他。 GDTR，即 GDT Register，专门用来存储 GDT 的内存地址及大小。GDTR 是个 48 位的寄存器。

![GDTR](/home/xiaoyao/desktop/TinyOS/photos/GDTR.png)

现在段寄存器中存的是叫选择子的东西，选择子**基本上**是一个索引值，用此索引值去GDT中寻找相应的段描述符。

![](/home/xiaoyao/desktop/TinyOS/photos/段选择子.png)

控制寄存器是 CPU 的窗口，既可以用来展示 CPU的内部状态，也可用于控制 CPU 的运行机制。

进入保护模式之前，需要将打开开关，PE位置1,启动保护模式。

![](/home/xiaoyao/图片/截图/CR0寄存器.png)

## 向内核迈进

### 1.获取物理内存容量

启用BIOS中断0x15功能

- 子功能0xe820

由于系统内部内存各部分的类型属性不同，此功能就是按照类型属性来划分这片系统内存，每次BIOS只返回一种类型的内存信息。

使用**地址范围描述符（ARDS）**来描述各种内存类型信息。

地址范围描述符的结构（共20个字节，160位）：

![ARDS](/home/xiaoyao/图片/截图/ARDS.png)

每一次int 0x15之后，BIOS就会返回这么一个结构。

调用前输入：

eax：子功能号

ebx：ARDS的后续值,第一次调用一定要置为0,每次中断返回值后BIOS都会更新此值。

es : di：ARDS缓冲区

ecx：ARDS结构的字节大小

edx：固定签名标记0x534d4150，此十六进制数字是字符串 SMAP 的 ASCII 码：BIOS 将调用者正在请求的内存信息写入 ES：DI 寄存器所指向的 ARDS 缓冲区后，再用此签名校验其中的信息

- 子功能0xe801

最大只能识别4G内存。检测到的内存是分别放在两组寄存器中。

<15M的内存以1k为单位，单位数量在ax和cx中记录，两个值一样，实际内存大小是ax✖1024

16M-4G的内存以64k为单位，数量在bx和dx中记录，两个值一样，实际内存大小是bx✖64✖1024

- 子功能0x88

只能识别最大64M的内存大小。

### 2.启动分页机制

分页机制本质上是将大小不等的段拆分成大小相等的页，也可以**理解成小内存块**。

CPU中一页是4K大小。

分页机制打开前要将**页表地址**加载到控制寄存器 cr3 中

![一级页表转成物理地址过程](/home/xiaoyao/图片/截图/一级页表转成物理地址过程.png)

例子：在一级页表的情况下，mov ax，[0x1234]来看，先将地址送入段部件得到一个线性地址，然后将线性地址送入页部件，经过转化得到其对应的物理地址。（熟悉一下顺序）

![二级页表转化过程图](/home/xiaoyao/图片/截图/二级页表转化过程图.png)

关键是**cr3寄存器(页目录基址寄存器)**存储的就是页目录物理地址。

![页目录项以及页表项](/home/xiaoyao/图片/截图/页目录项以及页表项.png)

自己设计页目录表和页表的内存布局

总个1024个页表，每一个页表占4K

 ![布局](/home/xiaoyao/图片/截图/布局.png)

将来内核运行在3G以上的空间，打印功能也应该在内核中实现，用户肯定不可以直接操作显存，所以显存的段基址也要改为3G以上才可以。

我们设计的低端 1MB的虚拟内存空间，其与物理内存 1MB 是一一对应的，在 0～1MB 之间，访问其中任何一个虚拟地址，最终都转换成与其等值的物理地址。

### 3.加载内核

虽然目前第一个内核程序（简单的while循环）非常简洁，和电脑中真正的内核相差非常多，但是目的有两个：

- 演示如何加载内核
- 演示elf格式的文件解析

操作系统加载用户程序的时候无非就是jmp或者call，需要我们显示的指明地址在哪里。

之前的所有地址都是固定的，方法非常不灵活，需要调用方和被调用方提前约定好调用地址。

有没有一种灵活的方法让程序的加载地址不那么固定呢？——有，当然有，每个程序是单独运行的，所以可以在程序的头部设置一段空间，在这个空间中写入程序的入口地址，调用的时候规定从程序的相应空间中将程序的入口地址读出来，**紧接着把程序体整体复制到执行文件的入口地址（这个入口地址应该之前设置的一样）**，然后再加载到执行文件的入口地址执行，jmp过去就可以了。

程序的文件头就记录着这部分信息，记录着描述程序布局等信息——也称为元信息。

还有一个问题就是程序头我们完全可以自己指定，只要保证最后按照我们的格式来解析就可以。

但是这样毕竟不通用，为了通用性最后就采用了gcc生成的elf文件格式。

生成可执行文件的过程：**源程序编译成目标文件，再将目标文件链接成二进制可执行文件。**

目标文件也称为待重定位文件，重定位文件就是指文件里面用到的符号还没有安排地址。所以一律在链接阶段对符号进行重定位。

**链接可以指定最终生成可执行文件的起始虚拟地址。**

链接器规定，默认只把名为_start 的函数作为程序的入口地址，即默认的 entry symbol 是_start，除非另行指定。

#### elf——Executable and Linkable Format，可执行链接格式（文件格式）

程序中最重要的就是段和节了，他们是真正的程序体。多个节经过链接之后就被合并为一个段了。

段和节的信息也是用header来表示的。因为程序中段和节的数量以及大小不固定，专门找了个数据结构存储他们，就是程序头表（program header table）和节头表(section header table)。两个既然都是表，这说明表里面存储的是多个程序头 program header 和多个节头 section header 的信息。

程序头表其实就是用来描述段的，也可以称作段头表。

用一个固定大小的数据结构来描述程序中程序头表和节头表的大小以及位置信息，我们称为ELF header——位于文件最开始的地方，并且具有固定大小。

<img src="/home/xiaoyao/图片/截图/elf header.png" alt="elf header" style="zoom:150%;" />

程序头表中的每个条目是用来描述各个段的信息的，来看每个条目的数据结构。

程序头表中描述的段是位于磁盘上的程序中的一个段，也就是磁盘上的程序文件中的内容格式，并不是之前的内存中的段。

![program header](/home/xiaoyao/图片/截图/program header.png)

![ELF文件格式布局](/home/xiaoyao/图片/截图/ELF文件格式布局.png)

简单的第一个内核文件main.c编译成elf目标文件之后，查看部分相关信息。

具体的在文件中二进制表现形式如图：

![每一个字节的表现形式](/home/xiaoyao/图片/截图/每一个字节的表现形式.png)

左边的是在文件中的偏移量，**中间的是文件中的内容**，按照16进制输出，两个16进制是一个字节，一行共有16个字节。

7F，45,4c,46分别是e_ident[0]，e_ident[1],e_ident[2],e_ident[2]的内容，其他的会依次类推。

**思考：我们在程序中的结构体等变量最终都是通过编码来在文件中存储的，只要我们找准文件偏移量就可以将文件中的这些数据读取出来，然后再进行相应的处理。**

我们还可以通过readelf命令来具体查看相关信息：

![readelf命令](/home/xiaoyao/图片/截图/readelf命令.png)

-e 参数相当于'-h' + '-l' + '-S'，能让大家看到 elf header(file header)、program header 和 section header。

可以通过这个命令来简单的看看elf文件中的相关信息。

#### 将内核载入内存

- 加载内核：把内核文件加载到内核缓冲区，意思是把内核从硬盘上拷贝到内存中，并不是运行内核代码。
- 初始化内核：**在分页之后，将加载进来的elf内核文件安置到相应的虚拟内存，然后跳过去执行**

加载到内核缓冲区，必须有一个加载地址。

内核被加载到内存之后，解析elf结构之后必须生成内核映像（复制各种段），这个映像才是真正执行的内核。

搬运指令族：movsb,movsw,movsd

其中movs代表move string，b代表Byte,w代表word,d代表dword

所以分别的含义是：复制1个字节，复制2个字节，复制4字节

![初步加载内核之后的内存布局](/home/xiaoyao/图片/截图/初步加载内核之后的内存布局.png)

#### 特权级部分



CPL（Current Privilege Level）,即当前特权级

DPL，即 Descriptor Privilege Level，描述符特权级，也是未来的CPL。

RPL，即**请求特权级,他代表了真正请求者的特权级**。

当前特权级是对处理器而言的,并不是对代码段而言的。

门描述符

**它们与段描述符最大的不同是除了任务门外，其他三种门都是对应
到一段例程，即对应一段函数。**

![四种门描述符结构](/home/xiaoyao/图片/截图/四种门描述符结构.png)

调用门的执行流程：

![调用门的执行流程](/home/xiaoyao/图片/截图/调用门的执行流程.png)

调用门就是一个描述符。

call 调用门选择子，该选择子指向了某个门描述符，处理器通过选择子中的索引找到门描述符的地址。门描述符中记录的是内核例程（一段函数）所在代码段的选择子以及偏移量，处理器再使用代码段选择子重复之前的流程，找到内核代码段描述符之后，在代码段描述符中找到内核代码段基址，再加上门描述符中记录的内核例程在代码段中的偏移量，最终得到内核例程的起始地址。

找到内核例程的相关起始地址之后，我们就从用户的3级特权变为内核的0级特权，我们如果要传入参数应该怎么做呢？

处理器在固件上实现了参数的自动复制，也就是说**用户进程压在3特权级栈中的参数会自动复制到0特权级栈中**，所以在门描述符高32位的地方有参数个数。

**当前请求资源者和资源需求方有可能不是一个人，引入RPL的目的就是为了让受访者知道，不管当前的请求者是不是中间人，即使他是代替别人来拿数据的，他也必须要有获取数据权限才可以，否则不允许当前的请求者获取数据。**

举个例子，mov ds，ax 时便会触发特权级检查。ax 中的值**被当作选择子**，处理器会拿 ax 中的低 2 位即 RPL 和 CPL **分别与** ax 中选择子所指向的段描述符的 DPL 做比较，如果满足 RPL≤DPL && CPL≤DPL，**选择子才能被加载到 DS 中**。

jmp指令的对应的前后特权级是平级转移，jmp指令只应用于不需要特权级变化，并且不从调用门返回的结果。

内存段不仅有特权级，指令也有特权级。

![eflags](/home/xiaoyao/图片/截图/eflags.png)

IOPL是IO特权级，他决定了当前任务是否可以操作所有的IO端口。只有任务的当前特权级>=IOPL的时候，才会允许执行全部的IO指令。

如果当前任务的特权级<IOPL的时候，也就是在数值上CPL < IOPL的时候，可以通过IO位图对相应的端口进行访问。

IO位图是位于TSS中的，他可以存在，也可以不存在。

![TSS中的IO位图](/home/xiaoyao/图片/截图/TSS中的IO位图.png)

在TSS中的哪里去找IO位图呢？怎样证明IO位图不存在呢？

有一项是“I/O 位图在 TSS 中的偏移地址”，它在 TSS 中偏移 102 字节的地方，占 2 个字节空间。

TSS 中如果有 I/O 位图的话，它将位于 TSS 的顶端，这就是 TSS 的实际尺寸并不固定的原因，当包括 I/O 位图时，其大小是“I/O 位图偏移地址”+8192+1 字节；若不包括 I/O 位图，其大小则为最小尺寸 104 字节。

既然 I/O 位图位于 TSS 内，那它的地址必须是在 TSS 的尺寸范围之内，即地址的范围是在 TSS偏移（104 ～TSS 段界限 limit）之间，如果偏移地址不在此范围，即大于等于 TSS 段界限 limit（TSS 尺寸大小-1），则表明没有 I/O 位图。

## 完善内核

### 1.函数约定简介

采用cdecl标准

- 参数是在栈中传递的

- 调用者将所有的参数从右向左入栈
- 调用者清理参数所占的栈空间
- eax，ecx，edx寄存器是由调用者保存的，其余寄存器是由被调用者保存的
- 函数的返回值存储在eax寄存器

### 2.汇编语言和c语言混合编程

单独的汇编文件代码和单独的C语言文件分别编译成目标文件之后，一起链接成可执行程序



global关键字将符号导出为全局属性，对程序中的所有文件可见，这样其他外部文件中也可以引用被global导出的符号。其实就是供外部使用。

引用外部文件的符号用关键字extern声明。



在c语言中嵌入汇编代码，直接编程生成可执行程序

### 3.实现自己的打印函数

Address Register 和Data Register这两个寄存器到底是干什么的？

前者是作为寄存器数组的索引，后者在寄存器数组中对应的寄存器相当于一个窗口，往此窗口中读写的数据都作用在索引所对应的寄存器上了。

即使是这样的，我还是没有理解这样做的目的！！！！

![CRT系列寄存器](/home/xiaoyao/图片/截图/CRT系列寄存器.png)

光标坐标用16位来表示，低八位表示列号，高八位表示行号。

光标值乘以 2 后便是光标在显存中的相对地址。

光标的坐标是存储在光标寄存器中的，索引为 0Eh 的 Cursor Location High Register 寄存器和索引为 0Fh 的 Cursor Location Low Register 寄存器，分别用来存储光标坐标的低 8 位和高 8 位地址。

![滚屏](/home/xiaoyao/图片/截图/滚屏.png)

### 4.AT&T语法

寄存器前有前缀%

源操作数在左，目的操作数在右

指令的最后一个字母表示操作数的大小，b表示1字节，w表示2字节，l表示4字节

立即数前有前缀$，在此语法中内存地址是第一位，一般情况下操作数是数字就默认是内存地址，除非改成立即数

例如：movl %eax, 1

此语法内存寻址有固定的格式：

segreg(段基址):base_address(offset_address, index, size)

对应的表达式是：segreg = base+offset+index*size

- base是基地址，可以是整数或者变量名，可正可负
- offset和index必须是8个通用寄存器之一,所以必须加%
- size是个长度，只能是1,2,4,8

另外需要注意的是格式中没有的部分必须用，来占位

movl %eax,(,%esi,2)

功能是将 eax 的值写入 esi*2 所指向的内存。

movl %eax,(%ebx,%esi,2)
功能是将 eax 的值写入 ebx+esi*2 所指向的内存。

movl %eax,base_value(,%esi,2)
功能是将 eax 的值写入 base_value+esi*2 所指向的内存。

movl %eax,base_value(%ebx,%esi,2)
功能是将 eax 的值写入 base_value+ebx+esi*2 所指向的内存。

#### 基本内联汇编

基本格式：

asm [volatile] ("assembly code")

各关键字之间可以用空格或制表符分隔，也可以紧凑挨在一起不分隔，各部分意义如下：
1.关键字 asm 用于声明内联汇编表达式，这是内联汇编固定的部分，不可少。

asm 和_ _asm _ _是一样的，是由 gcc 定义的宏：#define _ _  asm _ _ asm。

2.关键字 volatile 是可选项，它告诉 gcc：“不要修改我写的汇编代码，请原样保留”。

3.“assembly code”是咱们所写的汇编代码，它必须位于圆括号中，而且必须用双引号引起来。assembly code 甚至可以为空

规则：

- 指令必须用双引号引起来，无论双引号中是一条指令或多条指令
- 一对双引号不能跨行，如果跨行需要在结尾用反斜杠'\'转义
- 指令之间用分号'；'、换行符'\n'或换行符加制表符'\n''\t'分隔。
- 除最后一个双引号外，其余双引号中的代码最后一定要有分隔符

asm(“movl $9,%eax;””pushl %eax”)  正确
asm(“movl $9,%eax””pushl %eax”)   错误

**在基本内联汇编中，若要引用 C 变量，只能将它定义为全局变量。如果定义为局部变量，链接时会找不到这两个符号。**

```c
char* str="hello,world\n";
int count = 0;
void main(){
asm("pusha; \
    movl $4,%eax; \
    movl $1,%ebx; \
    movl str,%ecx;\
    movl $12,%edx;\
    int $0x80;\
    mov %eax,count;\
    popa\
    ");
}
```



#### 扩展内联汇编
